---
title: 80386
author: lonelywatch
date: 2024-5-4 21:28 +0800
categories: [X86]
tags: [X86,c80386] 
---


# 80386

[80386](https://en.wikipedia.org/wiki/Intel_80386) 是Intel于1985年推出的一款32位微处理器，是Intel 80286的后继产品。80386是Intel**首款支持32位操作系统**的微处理器，同时也是Intel支持虚拟内存的微处理器。




## 执行模式

80386总共有3种执行模式，分别是:

- **实模式**(Real Address mode): 机器初始化后会进入该模式，被看作是8086的拓展，带有新的指令。大多数情况下，都只会将实模式用于初始化。

- **保护模式**(Protect mode):

- **V86模式**(Virtual 8086 mode):

## 启动流程

### BIOS

BIOS位于ROM中，在机器上电后由硬件负责载入RAM,首先跳转到0xFFF0处执行长跳转指令到BIOS的入口地址，然后执行机器自检与硬件初始化等工作；在这一过程结束后，BIOS会尝试寻找包含引导扇区的设备，通过检查设备第一个扇区的最后两个字节是否为`0x55AA`来判断是否为引导扇区，如果找到就会将该扇区内容复制到0x7C00处并跳转到该地址执行启动代码。

值得注意的是，BIOS运行时机器会处于16位的保护模式。

### 主引导扇区

下面是对主引导扇区组成的详细介绍。

### 启动盘制作

## 寄存器

### 通用寄存器


![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728143615076.png)


I386拥有8个32位GPR,分别是`EAX`，`EBX`，`ECX`，`EDX`，`ESI`，`EDI`，`EBP`，`ESP`。这些寄存器可以分为两类，分别是**数据寄存器**（前四个）和**指针寄存器**。

4个数据寄存器可分为低16位的**AX**，**BX**，**CX**，**DX**，对于这四个16位寄存器，可以分别访问其低8位和高8位，分别为**AL**，**AH**，**BL**，**BH**，**CL**，**CH**，**DL**，**DH**。后面4个指针寄存器不可再分。

需要注意，虽然它们被称为通用寄存器，在实际代码中，它们都具有一定的规定用途（强制必须使用）。



### 段寄存器

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728143816817.png)

段寄存器共有6个，分别是`CS`，`DS`，`SS`，`ES`，`FS`，`GS`。这些寄存器用于存储段地址，上图已经标注了每个段寄存器中所存放段的用途。

### 标志寄存器与指令寄存器

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728144015694.png)

I386中的指令寄存器为32位的`EIP`用于存放下一条指令的地址，标志寄存器为32位的`EFLAGS`，其中的每一位都有特定的含义，下面是`EFLAGS`的结构：

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728144122539.png)

X86中的条件指令以及指令触发的异常都与标志寄存器有关，因此在编写汇编代码时，需要注意标志寄存器的状态。

### 系统寄存器

I386中的系统寄存器类型主要有：

- 标志寄存器

- 内存管理寄存器

- 控制寄存器

- 调试寄存器

- 测试寄存器

#### 标志寄存器

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728144837690.png)

标志寄存器存放了表示执行模式，中断与异常，IO权限等信息的标志位。

#### 内存管理寄存器

主要包括了：

- **GDTR**: 全局描述符表寄存器

- **LDTR**: 局部描述符表寄存器

上面的两个寄存器指向了GDT和LDT的地址。

- **IDTR**: 中断描述符表寄存器

IDTR指向了中断处理函数的入口地址。

- **TR**: 任务寄存器

TR负责被CPU用于标识当前任务。

#### 控制寄存器

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728145235652.png)

主要包括了：**CR0**, **CR2**, **CR3**。

#### 调试寄存器

主要提供了断点寄存器，能够不修改代码段就能够在指定地址设置断点。

### 系统指令

#### 任务相关

- **LTR**: 读TR

- **STR**: 写TR

#### 地址相关

- **LLDT**: 读LDT

- **SLDT**: 写LDT

- **LGDT**: 读GDT

- **SGDT**: 写GDT

#### 验证指针

- **ARPL**: 调整RPL

- **VERR**: 验证读

- **VERW**: 验证写

- **LAR** : 读访问权限

- **LSL** : 读段限制

#### IO相关

- **IN**: 读端口

- **OUT**: 写端口

- **INS**: 读端口串

- **OUTS**: 写端口串

#### 中断相关

- **CLI**: 关中断

- **STI**: 开中断

- **LIDT** : 读IDT

- **SIDT** : 写IDT

#### 控制相关

- **HLT** : 停CPU


## 指令格式

待补充。


## 内存管理

### 内存模型

I386支持4GB大小的物理内存空间，支持两类内存模型：

- **Flat Model**: 最多4GB的线性地址空间

- **Segmented Model**: 最多由16383个线性地址空间组成的段地址空间，其中每个线性地址空间最多4GB大小。

对于**Segmented Model**，地址主要由**段选择器**和**段内偏移**两部分组成。


![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728143138197.png)

### 数据类型

I386中的基本数据类型有**字节**，**字**，**双字**。需要注意I386手册中提出字与双字的地址并不需要对齐其数据大小，如果使用RUST等对数据对齐有一定要求的语言，需要注意这一点。

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728143122725.png)

在I386中同样需要注意数据的大小端，I386是小端模式，对于某些文件系统或者网络协议需要注意处理好字节序，下面的图片很好地展示了I386的字与双字的布局。

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728143240923.png)

除了上面的类型以外，I386还支持**BCD**(Binary Coded Decimal)类型，BCD类型是一种用二进制编码十进制数的方式，可以用来进行十进制数的运算。BCD码又分为未压缩BCD码和压缩BCD码。

### 地址转换

I386中的地址转换主要由逻辑地址（由16位段选择器和32位段内偏移两部分组成）转换为线性地址，线性地址转换为物理地址两部分组成。下图是I386中地址转换的示意图。

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728145235652.png)

从上图也可以看到I386中逻辑地址，线性地址与物理地址的组成。

#### 段翻译



段翻译负责将逻辑地址（段地址：段内偏移）翻译成线性地址，主要涉及到：

- 描述符

- 描述符表

- 段选择器

- 段寄存器

下图是该过程的具体表述：

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728185328621.png)


从图中可以看到，根据段选择器从段描述符表中选取对应段描述符，得到其基地址并与段内偏移相加便得到了其线性地址。

##### 描述符

描述符负责为CPU提供用于段地址翻译的数据。描述符通常由编译器与操作系统等系统软件创建，主要组成如下：

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728185620652.png)

- `BASE`: 主要用于定位4GB线性地址中段的位置，CPU将3个BASE 组合成32位值

- `LIMIT` : 定义段大小，如果标志位中Granularity位为1，则单位为4KB，否则为1B

- `TYPE` : 用于区分不同种类的描述符

- `DPL` : 描述符特权级，用于实现保护机制

- `Segment present bit`:用于表示描述符是否有效

- `Access bit` : 是否被访问过

##### 描述符表

描述符可被存放于`GDT`（全局描述符表）或者某个`LDT`（局部描述符表）中。 描述符表只是存放于内存之中的8字节entry组成的数组，如下图所示：

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728192729783.png)

##### 段选择器

段选择器用于寻找对应的段描述符，其组成如下：

- Index: 表示描述符在表中的下标

- Table Indicator : 表明描述符表种类（0位GDT,1为当前LDT）

- Requested Privilege level : 用于保护机制

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728192851839.png)


##### 段寄存器

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728193122039.png)

#### 页翻译

从前面可以得知，线性地址由DIR,PAGE,OFFSET三部分组成，页翻译使用两级页表将线性地址转化为物理地址。这一部分其实是可选的，当CR0寄存器中的PG位为1时才会开启，并且I386使用4K物理页框。 翻译时I386使用DIR域寻找一级页表中的页表项，使用PAGE寻找二级页表中的页表项进而得到其物理页，最后使用页内偏移得到其物理地址。

下面是页翻译的具体流程：

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728193832865.png)

在I386中，每个页表占据一页物理内存，及4KB,并且每个页表项4B，故有1K个页表项。**当前页表的物理地址被存放在CR3中**，下面是页表项的组成：

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728194045555.png)

### Cache与TLB



## 异常与中断

![](https://lonelywatch-1306651324.cos.ap-beijing.myqcloud.com/image-20240728144430762.png)

上面是I386中的中断向量表，I386中的中断分为**中断**和**异常**两种，I386将中断视为异步异常，而将异常视为同步异常，中断是外部设备发起，而异常由CPU内部发起。


## IO

I386中的IO主要有两种方式：

- **Port-Mapped IO**: 通过端口号来访问IO设备(特定的IO指令)

- **Memory-Mapped IO**: 通过内存地址来访问IO设备（普通的内存读写指令）

### 端口IO

地址空间总共64K大小，访问可以以字节，字，双字的形式进行访问，以字或者双字的形式访问IO的地址需要注意地址对齐以便能够作为总线地址。


使用`INT`与`OUT`指令进行端口IO间的数据传输，使用`INTS`与`INS`指令进行数据流IO数据传输。
在使用`INT`和`OUT`时使用的GPR是EAS,AX与AL。而在使用`INS`和`OUTS`时使用的GPR是ES,ESI（地址由ES:EDI组成）。

### 内存映射IO

使用普通的内存读写指令进行IO设备的访问，并且这些地址和普通的内存地址一样，都会受到I386的保护。




