---
title: 数据库系统原理
author: lonelywatch
date: 2023-09-5 15:14
categories: [数据库]
tags: [数据库,SQL]
---

## 开始

概念庞杂而缺少完整的俯瞰,仿佛雾里观花,不知全貌。

----

对于数据的处理经历了 程序内处理数据,文件系统,以及现在的数据库系统这么三个阶段。

相比于使用数据库系统,文件系统有很多缺点：

- 数据冗余大,浪费空间,并且不利于维护和管理(数据分散,格式也可能不一致,应用程序更新与维护难度大)。
- 一致性,安全性,完整性等问题难以保证(安全性：数据具有访问权限。一致性：对于不同处的同一数据,必须保证内容相同。完整性：**一致性约束**,对于每个属性都有其**域**)。
- 并发访问异常,并且原子性问题难以解决。

**数据库系统**是 一组相互关联的数据以及一组使得用户可以对数据进行操作的程序的集合。其主要目的为 给用户提供数据的抽象视图,并且隐藏关于数据存储与维护的细节。

### 数据抽象

在数据库系统中,可以抽象出**物理层**(内模式),**逻辑层**(模式),**视图层**(子模式)(名称因人而异)这么三个层次。其中又存在着**内模式-模式**,**模式-子模式**这么两个**映像**。这种架构很好地解决了文件系统存在的问题。

- 物理层：描述数据的物理存储结构。
- 逻辑层：描述数据的逻辑存储结构和元数据(数据的数据,描述数据的关系,数据的语义等)。
- 视图层：为用户提供对数据的接口。

### 实例与模式

**数据库模式**：数据库的总的设计。

**数据库实例**：数据库中某一时刻所有信息的集合。

类似于类与对象(可能并不恰当)。

### 数据库语言

数据库语言可分为**数据定义语言**(DDL)和**数据操纵语言**(DML)。

#### 数据定义语言

数据定义语言描述了如何去定义一个 数据库模式。 比方在SQL中的create语句就会创建一个数据库。

#### 数据操纵语言

对数据进行CRUD操作的语言。

可分为

- 声明式DML：使用数据时只需要指明数据。
- 过程式DML:   除了指明数据外,还需要指明数据的来源。



### 数据独立性与数据模型

**数据独立性**有：

- 物理独立性： 应用程序并不依赖于物理层。

- 逻辑独立性：应用程序并不依赖于逻辑层。

**数据模型**有这么几种：

- E-R模型

- 关系模型

- 半结构化模型

- 面对对象模型

### E-R模型介绍

E-R模型由**实体**(Entity)与**关系**(Relation)组成。

- 实体： 客观世界中可区别于其他对象的“物体”或“事情”。对于实体,使用**属性**来描述实体。
- 联系：两实体间存在的联系。

同一类型组成的所有实体集合为**实体集**,同两实体间的所有联系为**联系集**。

可以使用**E-R图**来描述E-R模型(可以使用UML(统一建模语言)来绘图)。

对于一个E-R图：

实体集使用矩形表示,其中 实体集名字在上面,属性名在下面。

关系集使用连接两实体集的菱形表示,中间包含关系名。

### 数据存储和查询



#### 存储管理器

存储管理器是数据库系统中负责在数据库中存储的低层数据与应用程序,以及向系统提交的查询提供接口的部件,负责与文件系统进行交互。

主要包含：

- 权限及完整性管理器：负责检查**完整性约束**以及权限。
- 事物管理器：保证即使出现故障,数据库也会保持正确的状态,并且确保并发事物不冲突。
- 文件管理器：负责与文件系统进行交互,管理磁盘上存储信息的数据结构。
- 缓冲区管理器：将数据从磁盘读入内存。

存储管理器实现了以下数据结构：

- 数据文件
- 数据字典(元数据)
- **索引**(提供指向包含特定值的数据的指针)

#### 查询管理器

主要包括：

- DDL解释器：负责解释DDL语句,并且将定义记录在 数据字典 中。
- DML解释器：将DML转化成执行方案(执行引擎能理解的低级语句)。

- **查询执行引擎**： 执行DML解释器生成的低级指令。

### 事物处理

**事物**是 数据库应用中完成单一逻辑功能的操作集合。

要求**原子性**(执行中的操作不可中断),**一致性**,**持久性**。

**事务管理器**中包含 恢复管理器 和 并发控制管理器。

原子性与一致性 由 **恢复管理器**来保证(故障发生时,恢复之前的状态来保证原子性和一致性)。

**并发控制管理器**负责管理并发事物的相互影响,从而保证一致性。

### 应用体系

数据库系统的应用体系常见的有 **二层体系** 和 **三层体系**。

- 二层联系： 应用程序与DBMS分别在客户机和服务机上。其中业务逻辑部署在客户机上。
- 三层联系： 和二层联系不同的是,客户机上只存在表单与服务器进行交互,其中的业务逻辑被放在了服务端上。(这种体系常被用于大型系统与互联网程序。)

## 关系型数据库

### 表 

关系型数据库由**表**的集合组成。

对于一个表,有着若干行和若干列。

- 行：表中一组值的联系,对于这种联系,可以使用元组来表示(元组无序)。
- 列：是表(或者说是**关系**)的属性。

在关系型数据库中,**关系**指代表,而**元组**指定行(或者通俗的说是**记录**)。

**域**：表中属性的所有取值集合。我们要求表中的所有取值都必须是**原子**(不可再分)的。

### 数据库模式

**数据库模式**是数据库的一个定义,而**数据库实例**则是数据库模式的一个快照。

对于**关系模式**也是类似。关系模式类似于高级程序语言中的变量类型,而**关系**则是定义的变量。

### 码

**超码**是关系属性集合的一个子集,为了区别两个不同的元组,两个元组在超码上不可能完全相同。(任何**超码**的超集都是超码,我们通常说 其中的 最小集为**候选码**),在数据库中,超码被称为**主码**。

**外码**表示一个关系中包含着另一个关系的属性子集。其中被包含关系被称为 该外码依赖的**被参照关系**,包含关系被称为该外码以来的**参照关系**。

### 模式图

对于含有主码和外码依赖的数据库模式 可以 使用**模式图** 。

在模式图中,关系使用矩形表示,关系名在上面,属性在下面。

在关系中,主码通过在属性名下使用下划线来表示。外码通过依赖关系指向被依赖关系的箭头表示。

### 关系查询语言

对于查询语言可以是**过程化**(除了数据的信息,还需要给出一系列的操作)的,也可以是**非过程化**(只需给出信息)的。

## SQL

这里感觉没必要写。

### 介绍

SQL是一门查询语言(尽管包含许多其他的数据操作)。

SQL最早由IBM开发,最初名叫Sqeuel。

SQL语言有以下几部分：

- DDL：定义关系模式,对关系的CRUD。
- DML：对数据的CRUD。
- 完整性：SQL DDL中包含对完整性约束的命令,数据必须满足完整性约束。
- 视图定义：SQL DDL中包含定义视图的命令。
- 事物控制： SQL中包括定义事物的开始和结束的命令。
- 授权：SQL DDL中包含定义对关系和视图的访问权限的指令。

### 数据类型

SQL支持的数据类型有：

- char(n) :定长字符串
- varchar(n):不定长字符串,最大长度为n
- int: 整数
- smallint:小整数
- numeric:定点数
- float: 浮点数 

其中每种类型都包含**空**值。

### 操作

---

创建关系模式使用`create table <tbName> (...attributeList); `。

其中使用`primary key(a1,a2,...,an)`来指定主码,使用`foreign key(a1,a2,...,an) reference tbName `来指定外码。

---

使用`delete from tbName`语句来进行删除关系中的行。

使用`alter table`来修改关系。

...

使用`insert`来插入数据。

#### 查询

SQL基本查询结构由select,from和where组成。

select指定了返回的属性(使用`*`表示所有属性名),from指定了语句的输入关系,而where指定了对关系的筛选,最终返回一个关系。

##### 单关系查询

是说 输入只有一个关系(笑)。

有这么几个特性： 

使用**distinct**关键字去重(在选中的属性名前)。

使用**运算符**来进行处理属性。

使用 and or not 等来连接where的条件。

##### 多关系查询

也就是说 输入有多个关系。

如果不加where设置相应条件的话,返回的关系为 **输入关系的笛卡尔积**。

#### 自然连接

对于一个自然连接以两个关系作为输入,并且只会考虑在所选的属性集合都相等的元组对。

使用关键字`natural`来进行自然连接,比如：

```sql
select name, course_id
from instructor natural join teachers;
#选自《数据库系统概念》
```

事实上,在同一语句中,可以使用多次`natural`,将多个关系结合,

也可以将自然连接与 之前所说的 多关系查询结合。

#### 别名

使用`as`来重名。(在 (**代表着属性名或者关系名**)后使用)。

一个很有意思的运用就是,将同一关系多次放入from语句中使用。一个例子就是：

```sql
select distinct T.name
from student as T, student as S
where T.age > S.age and S.deprt_name = 'Chemistry';
```

别名也可以叫做**相关名称**或者是**相关变量**。

#### 字符串操作

sql提供了许多函数,其中一部分用来操作字符串。

比如`upper(s)`将s转化为大写,`lower(s)`转化为小写,使用`rim(s)`去除末尾空格。

一个更加重要的操作就是**模式匹配**,在SQL中使用`like`操作符来进行模式匹配。在模式匹配中,`%`匹配任意字符,而`_`匹配任一字符。并且模式是大小写敏感的。

#### 对输出排序

使用`order by`来对输出进行排序,其中`order by`的参数为属性名,并且默认是升序,使用`desc`(降序)和`asc`(升序)来显式指定(将关键字放在order by 后的属性名后)。

并且支持多关键字排序。

比方说：

```SQL
select * from students 
order by name desc, id asc;
```

#### between...and

等价于 大于等于与小于等于相结合。在where子句中使用。

还有一个很有意思的地方是：

在where子句中要比较多个值时可以使用元组来进行统一比较,比如：

```SQL
select * from student
where (id, name) = (1,'cc');
```

#### 集合运算

使用`union`,`intersect`,`except`来表示并,交,非等集合操作。

用法为 使用这些关键字与两个表(**任何可以代表 表 的东西**)相连接,比方说：

### 空值

空值是特殊的,对于空值的处理,比如在算数运算上,任何包含空值的运算的结果都为控制；任何包含空值的逻辑运算都为`unknown`(这是继真假后的第三个逻辑值,并且**任何包含unknown并且不能完全确定真假**的逻辑运算都为unknown).

### 聚集函数

是SQL函数中的一部分,用来处理属性值。

常见的有`avg`(平均值),`min`,`max`,`sum`,`count`(计数)。

#### 单组聚集

单纯地使用聚集函数。

#### 多组聚集

单组聚集和多组聚集不同的地方在于,聚集函数处理的对象是多组的。

也就是说,如果是单组聚集,那么返回值只有一个(对于一个聚集函数来说),如果是多组聚集,则返回值有多个(分别对每个组进行聚集)。

多组聚集使用`group by 属性名`。(**元组限定**)

比如说：

```SQL
select avg(grades) from student
group by dept_name;
```

并且对于不在分组属性集合中,并且也不完全相同的属性,是不能在这样的多组聚集中使用的。(对于一个分组,返回一个元组,如果那个属性不能完全相同,就不能确定该返回什么,所以会报错)。

使用`having 条件`子句来对分组进行限定。(**分组限定**)

---

在聚集中**对于空值的处理**：除 count(*)以外的聚集函数都会忽略空值。如果聚集函数输入的集合为空值,那么count的输出为0,其他聚集函数输出为空值。

### 嵌套子查询

嵌套子查询就是指嵌套select-from-where子句,并且该子句可出现在from和where子句中。

---

SQL中有 `in`和`not in`用于表示一个元组是否在一个关系中,比方说：

```sql
select * from  student 
where id in department;
```

如果与嵌套子查询结合起来,可以为：

```SQL
select * from student
where id in (select * from department
            where name = 'Cheems';
            );
```

#### some 和 every

就如英语语义一样,`some`表示若干,至少有一个,而`every`则表示所有。这两个关键字用来修饰关系,通常在使用比较条件时配合使用( > some , < some等)。

比如说；

```SQL
select * from student
where age = 20 and rank > some (select * from student
								where age = 21 and id > 100;
);
```

---

事实上,SQL的同一查询可能有多种表达,这种用户输入的冗余很大程度上赋予了SQL极大的灵活度。

---

#### exists

表示是否存在元组,如果后面的关系存在元组则输出true,否则false。同样有着`not exists`表示是否不存在。

---

#### unique

表示是否存在重复元组,如果后面的关系并没有则输出true,否则false。同样有着`not unique`。

---

外部查询的**相关变量**(或者说是**别名**)可以在子查询中使用,这种机制被叫做**相关子查询**。

### with

with子句可以定义临时关系,仅作用于包含with子句的语句中。基本和as连用,比如：

```SQL
with max_budget (value) as
 	(select max(budget)) from department)
 	select budget
 	from department, max_budget 
 	where department.budget = max_budget.values;
#选自《数据库系统概念》
```

### 标量子查询

如果子查询返回包含单个值的单个元组,就是**标量子查询**。

### 插入

除了简单的insert常量元素外,还能够使用select语句,从其他关系中选出某些元素进行插入。

```SQL
insert into teachAssist
	select ID,name,dept_name from student
	where dept_name = 'Doge';
```

这其实就是把返回的元组插入其中,就像常量那样。

### 更新

使用`update`来更新元组。

基本形式为：`update tbName set xx = xx,yy=yy,,, where xxx;`

特殊的是,SQL提供了**case语句**,用于取代比较时某个具体的值。

比如说：

```SQL
update instructor 
set salary = case
			when salary <= 100 then salary * 1.5
			when salary <= 200 then salary * 1.3
			else salary * 1.2
			end
```

case语句就是返回某个条件下特定的值。

这里同样能够使用标量子查询。

## 中级SQL

大概就是说,比之前的内容要高级一些.(qq)

---

### 连接

### 视图

用户看到的数据通常只是一部分,并且不同的用户需要的数据也可能不同。

**虚关系**在概念上包含查询的结果。任何这种不属于 逻辑模型,但是 作为虚关系对用户可见的关系 就是 **视图**。 视图 就像是在用户与 查询间 添加了一层。

视图并不会存储实际的值和计算,它只会存储查询表达式。

视图通过`create view 视图名 as 查询语句`来创建(更详细的方式为：可以像创建表那样指定若干属性名,同时查询语句返回的元组应该和定义的属性名相对应)。在使用时,视图可以出现在任何关系名能出现的地方。 

#### 物化视图

上面所说的是**定义视图**(只存储视图的定义而非其结果,每次使用时重新计算),而一些特定的数据库使用**物化视图**。对于物化视图,数据库会**存储该关系**,并且在原查询语句对应的关系修改会同步到该视图(可分为周期更新和时刻保持更新),这一过程称为 **物化视图维护**。

#### 视图与 查询之外的操作

视图被创建出来主要目的就是为了更好地查询,但是它仍然可以出现在任何关系能出现的地方。最好不要用视图来进行除查询之外的操作(简单地来说)。

### 事务

**事务**简单地说就是对数据的处理(由查询或更新语句的序列组成)。在SQL中,使用`Commit work`(提交事务,使得更新在库中长久保存),`rollback work`(回滚当前事务,撤销该事务对库的更新),利用这种回滚和提交的机制,使得 对数据的处理,变得具有“原子性”。

### 完整性约束

#### 单个关系上的完整性

对属性的域进行约束,保护数据库的一致性。防止数据被破坏。常见的有：

- not null
- unique
- check (\<谓词\>)

#### 参照完整性

主要针对外码。特殊的有,一般情况下,对于违反该完整性的语句,一般是报错拒绝执行。这种情况可以通过增加设置来改变,比如在定义表的外码时使用 `on update cascade`,`on delete cascade `时,如果违反了该参照完整性,就会进行 **级联**更新或删除。事实上cascade级联只是一种处理,也可以使用 set null 或者 set default 代替。  

### 其他的数据类型

- date (4位年),月和日
- time 时,分,秒
- timestamp 上面两个的集合。 

在SQL中使用`cast e as t`来讲字符串转化为类型t。对于时间,使用`extract (field from d)`来抽取单独的域。

#### 大对象类型

如果要存储一些较大的数据(比如图片和视频),就可以使用类型 clob(字符类型的大对象数据)和blob(二进制数据的大对象数据)

使用这些定义属性时 类似于`a1 blob(1GB)`这种。

对于查询元组,SQL使用一个“定位器”来检索这些大对象,并非直接将其放入内存中。

#### 索引

一种高效的查询方式。

### 权限

就如之前所说,数据库具有权限管理。

## 高级SQL

比之前的更高级点了。

##  数据库设计与E-R模型

数据库系统的设计主要包括,设计数据库模式,开发访问数据库的程序,设计控制数据访问的安全模式。

对于E-R模型,就如之前所说,包含 **实体集**,**关系集**,**属性**这么三部分。

对于属性,可能是简单的,也可能是复合的(在使用E-R图表示时使用嵌套的空格表示,类似于python),可能是单值的,也可能是多值的(通常使用两个中竖线将其属性括起来)。对于实体集,使用实线来连接,对于关系集,使用虚线来连接属性。

对于约束,主码通过下划线表示,外码通过实体集间的单向箭头表示。

对于**映射基数**(实体关系中的数量对应关系),如果是对1,那么关系到实体集就是箭头,如果是对多,就是一条线段。

(待补充)

---

关系型数据库的设计目标就是生成一组关系模式,使得避免不必要的冗余,并且能够方便地获取信息。这是通过设计满足适当**范式**来实现的。

对于将一个模式分解成两个模式,如果出现了不良影响,就为**有损分解**,否则为**无损分解**。

- **第一范式**(**INF**)：如果该模式所有属性的域都是原子的,那么该模式属于第一范式。

---

对于一个关系模式的实例,若该实例**满足函数依赖** $ a -> b  $ 的条件为：对于该实例中的任意元组对$t_{1}$和$t_{2}$ , 若$t_1[a] = t_2[a]$,那么 $t_1[b] = t_2[b]$

 如果对于一个函数依赖,在该关系模式上都满足,那么我们说 该依赖在该关系模式上成立。 

对于在任何关系上都满足的函数依赖称为 **平凡**的函数依赖。

- **Boyce-Codd 范式**(**BCNF**)

该范式能够消除所有基于函数依赖能够发现的冗余。

定义为：

具有函数依赖集$F$形如$ a -> b $函数依赖的关系,下列至少有一项成立：

1. $a->b$ 是平凡的
2. a是模式R的一个超码

对于不满足BCNF的关系,则至少存在非平凡的函数依赖$ a-> b$其中$a$并非该关系$R$的超码,通过下列两个关系来取代该关系：

- $ (a \cup b) $
- $ (R - (b - a)) $

这会消除所有不满足条件的函数依赖。

如果想要保持依赖,可以使用比BCNF更弱的**第三范式**。

---

- **第三范式**(**3NF**)：和BCNF相比,它允许一些左侧不是超码的非平凡依赖。

第三范式的定义为：

对于$F$(关系$R$的所有函数依赖集)中的形如$a -> b$的函数依赖,至少存在一项成立：

- $a -> b$ 是平凡的
- $a$是$R$的一个超码
- $b - a$  的每个属性都在R的一个候选码(最小的超码)中



----

----

## 范式

- 1NF：所有的属性都是原子的。
- 2NF：在1NF中，每个非主属性完全依赖于码 
- 3NF:在2NF中，每个非主属性都不传递依赖于码
- BCNF:
- 4NF:

## 函数依赖与模式分解

数据关系就是信息的表达，一个好的关系应该表达单一信息，否则会出现各种错误。

### 函数依赖

> 函数依赖：对于基于属性集U上的关系模式$R(U)$的任一具体关系r，其中X,Y为U子集，t,s是R的任意两元组，如果有 t[X] = s[X],则有t[Y]= s[Y],那么就说**X函数确定Y**，或者是**Y函数依赖X**。

通俗的来说就是每个X都有唯一Y对应。

函数依赖有这么几种：

- 平凡函数依赖：对于每个关系模式都成立，比如说Y是X的子集。

- 完全函数依赖：X是确定Y的最小属性集合。（使用f箭头）

- 部分函数依赖：X不是确定Y的最小属性集合。(使用p箭头)

- 传递函数依赖：X->Y,Y->Z,Z不函数确定X，那么X->Z。(使用t箭头表示)

  

#### 候选码

> - 候选码如果对于关系模式R<U,F\>，X完全函数确定U。
> - 主属性：候选码中的属性。

如果候选码多个，则选择一个成为主码。

#### 逻辑蕴含

> - 逻辑蕴含：对于关系模式R<U,F>，如果F能够推出X->Y，那么F逻辑蕴含X->Y。
> - 函数依赖集的闭包：F逻辑蕴含的全体就是其闭包，记作 $ F^{+}  $

#### Armstrong公理

- 自反律：如果U包含X包含Y，那么X -> Y.
- 增广律：如果X->Y，且Z包含于U，那么XZ->YZ。
- 传递律：~。

#### 属性集闭包

和函数依赖集的闭包类似，属性集闭包是指属性集能够函数确定的全体。同样用+右上表示。

#### 最小依赖集

最小依赖集针对的是 函数依赖集F，其中满足：

- 被确定的都是单一属性
- 用来确定的都是最小集合
- 不存在多余的函数依赖

转化为最小依赖集需要：

1. 将被确定的属性，全部转化为单一属性。
2. 去除用来确定的多余属性
3. 去除多余的函数依赖

### 模式分解



#### 无损分解

#### 保持函数依赖



## 数据库设计

$$
\textbf{需求分析} \rightarrow \textbf{物理，逻辑设计} \rightarrow \textbf{实施}
$$

### 需求分析

- 使用**数据流图**（DFD）表示数据与处理之间的关系
- 使用**数据字典**（DD）表示对数据的描述。

#### 数据流图

DFD表示数据的流动，采用结构化方法SA自顶向下逐层地进行表示。

#### 数据字典

DD表示数据的属性，通常采用表的形式。

### 概念结构设计

使用`E-R`图描述需求分析得到的信息，得到的信息结构就是**概念结构**。采用自底向上的方法，先逐层向上描述分概念结构，最后将所有的分E-R图综合形成总的E-R图。

### 规范化

使用模式分解和范式来得到健全的数据库逻辑模式。
