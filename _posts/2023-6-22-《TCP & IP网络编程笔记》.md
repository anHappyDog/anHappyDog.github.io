---
title: 《TCP & IP网络编程》笔记
author: lonelywatch
date: 2023-6-22 15:14 +0800
categories: [计网]
tags: [计网,linux,windows,tcp]
---

# 《TCP&IP网络编程》

这是一本完全面向初学者的网络编程书,《计算机网络》中的概念太多，我学到一半决定还是先从实用的角度开始，这本书其实我大一尝试看过一点，但也是浅尝辄止，现在拾起来重新学习。

## 第一章

作者直接给出了在windows和linux下的“hello,world”，根据几段程序讲解了服务端与客户端的流程。

在linux下：

```c
//hello_client.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(const char* message) {
	fputs(message,stderr);
	fputc('\n',stderr);
	exit(1);
}

int main(int argc, char** argv) {
	int sock;
	struct sockaddr_in serv_addr;
	char message[30];
	int str_len;
	if (argc != 3) {
		
		printf("Usage : %s <IP> <port>\n",argv[0]);
		exit(1);
	}
	sock = socket(PF_INET,SOCK_STREAM,0);
	if (sock == -1) {
		error_handling("socket() error");
	}
	memset(&serv_addr,0,sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = inet_addr(argv[1]);
	serv_addr.sin_port = htons(atoi(argv[2]));

	if (connect(sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr)) == -1) {
		error_handling("connect() error");
	}
	str_len = read(sock,message,sizeof(message) - 1);
	if (str_len == -1) {
		error_handling("read() error");
	}
	printf("Message from server : %s \n",message);
	close(sock);
	return 0;
}

// hello_server.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(const char* msg);

int main(int argc, char**argv) {
	int serv_sock;
	int clnt_sock;

	struct sockaddr_in serv_addr;
	struct sockaddr_in clnt_addr;
	socklen_t clnt_addr_size;
	char message[]= "Hello world";
	if (argc != 2) {
		printf("Usage : %s <port>\n",argv[0]);
		exit(1);
	}
	serv_sock = socket(PF_INET,SOCK_STREAM,0);
	if (serv_sock == -1) {
		error_handling("socket() error");
	}
	memset(&serv_addr,0,sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_addr.sin_port = htons(atoi(argv[1]));

	if (bind(serv_sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr)) == -1) {
		error_handling("bind() error");
	}
	if (listen(serv_sock,5) == -1) {
		error_handling("listen() error");
	}
	clnt_addr_size = sizeof(clnt_addr);
	clnt_sock = accept(serv_sock,(struct sockaddr*)&clnt_addr,&clnt_addr_size);
	if (clnt_sock == -1) {
		error_handling("accept() error");
	}
	write(clnt_sock,message,sizeof(message));
	close(clnt_sock);
	close(serv_sock);
	return 0;
}

void error_handling(const char* message) {
	fputs(message,stderr);
	fputc('\n',stderr);
	exit(1);
}

```

​	书中说，网络编程就是套接字(socket)编程。

对于服务端，需要这么几步：

- 创建套接字： `socket(int domain,int type,int protocol)`,其中`domain`为指定的 **协议簇**，大致有 `AF_INET`(IPV4),`AF_INET6`(IPV6),`AF_LOCAL`(本地),`AF_PACKET`(原始数据包）。`type`为套接字的通讯方式,取值有`SOCK_STREAM`(流，可靠)，`SOCK_DGRAM`(数据包，不可靠),`protocol`指定具体的协议，通常取0，返回值为-1表示失败。

- 调用`bind`为套接字分配地址:`int bind(int sockfd,struct sockaddr* myaddr, socklen_t addren)`。在linux中，socket被认为是文件的一种，可以通过文件I/O使用（windows不同）`sockfd`为socket描述符，`myaddr`为指向`struct sockaddr`的指针，后面为该结构体的长度，返回-1表示失败。

  其中`struct sockaddr_in`与`struct sockaddr`被定义如下：

```c
struct sockaddr_in {
    sa_family_t sin_family;     // 地址族，在 bind/connect 时通常设置为 AF_INET
    in_port_t sin_port;         // 端口号，使用网络字节序表示
    struct in_addr sin_addr;    // IPv4 地址， INADDR_ANY  表示适用任何地址
    unsigned char sin_zero[8];  // 填充，用0填充以保持与 struct sockaddr 大小相同
};
  
struct in_addr {
    in_addr_t s_addr;  // IPv4 地址，使用网络字节序表示
};
  
//网络中的通信基本为进程或者线程的通信（我记不清是那个了，，）每个通信者占据一台计算机的一个端口，以此来区分一个ip地址的不同通信者，同时TCP与UDP分别使用端口，如果一个端口被TCP占用，它还可以使用UDP。
//使用套接字需要为他注册这么一个“门牌”方便寻址。

```

​	关于宿主机的大小端与网络节序的问题：

- 使用`listen`监听请求：`int listen(int sockfd, int backlog)`

  分别使用sockfd以及

- 使用`accept`接受请求:  `int accept(int sockfd, structaddr* addr, socklen_t* addrlen)`：这里与socket类似，但是通过传入表示大小的指针来返回结果。

对于客户端，则只需要：

- 创建套接字(同服务端)

- 使用`conncect`发送请求`int connect(int sockfd,struct sockaddr* serv_addr, socklen_t addrlen)`，与socket类似。

在windows下需要额外的操作，同时socket是与文件分开的，只需要在编译的时候引入winsock32就可以了。

在windows中，需要使用`WSAStartup`开始使用库，`WSAcleanup`结束对库的使用，`send`与`recv`分别发送和接受信息，`SOCKET` 为socket等函数的返回句柄类型。

### 习题

1. 套接字是数据发送与接受的载体，使得程序员能够从协议中解放出来，因其像插头一样将实体链接至互联网而得名套接字。
2. listen用于监听请求，而accept用于接受请求，建立连接。
3. linux将socket看作为文件的一种，windows并没有。
4. 需要根据ip地址和端口号来寻址，调用bind完成此过程。
5. 文件描述符（Linux）：文件描述符是一个非负整数，在Linux系统中用于标识打开文件、设备或套接字等资源。句柄是Windows系统中表示打开对象（例如文件、设备或套接字）的整数值。
6. ANSI标准定义的IO函数是与操作系统无关的，而底层文件IO与操作系统有关。
7. - - 

## 第二章

协议族在第一章已经说明，关于套接字类型有面向连接`SOCKET_STREAM`与面向消息`SOCKET_DGRAM`两种。

`SOCKET_STREAM`保证数据有序且可靠，并且套接字必须一一对应，没有数据边界。`SOCKET_DGRAM`强调速度，不可靠，可能会丢失，并且有数据边界。	

对于`PF_INET`与`SOCKET_STREAM`的组合，只有`IPPROTO_TCP`一种，即TCP连接。而`SOCKET_DGRAM`对应的组合则是`IPPROTO_UDP`。

是否存在数据边界，书中说只需要看读写次数是否对应。

### 习题

1. 协议指的是一组规则和约定，用于不同系统、设备或实体之间进行通信和交互。定义协议能够使得传输过程变得规范化，使得不认识的双方能够根据协议收发解析数据。

2. 可靠，有序，没有数据边界。

3. a,c,e。

4. UDP,TCP,TCP。

5. UDP，注意缓冲区大小和数据报的长度。

   

## 第三章

大端：最高有效位在低地址，小端：最高有效位在高地址.

关于网络字节序，统一为大端，通过相应函数可以将宿主的大小端转化为网络字节序`htonl`，`htons`,`ntosl`,`ntons`。network 与 host 关于 long与short的切换。

在linux中：

`inet_addr`(arpa/inet.h)将ip地址的字符串转化为32为网络字节序整数值。

`inet_aton`与`inet_addr`具有同样的功能。

`inet_ntoa`与`inet_aton`相反，将32位无符号数转化为字符串IP地址。

`INADDR_ANY`:自动为服务端分配地址。

在windows中：

并不存在`inet_aton`其他相同。

### 习题

1. IPV4 是32位地址，而IPV6是128位地址，IPV6在IPV4将会使用完的情况下产生。

2. 

3. 网络通信的基本节点是进程，一个主机占据一个IP地址，可能会有多个进程同时通信，需要占据不同的端口号进行区分。

4. IP地址分为网络地址与主机地址，分为A,B,C,D,E五个种类。其中A类地址首字节位0 ~ 127， B类为128~ 191 ，C类为192~ 223

   C,A,B

5. 实现外网与本网之间的数据交换。

6. 知名端口就是TCP网络中预先定义且特定保留的端口，FTP代表端口21，HTTP代表端口80，知名端口范围为0~1023

7. `struct sockaddr`中并不好操作，转化为`struct sockaddr_in`方便读取修改。

8. 大端序就是最高有效位在低地址，小端序就是最低有效位在低地址，网络字节序就是大端序。因为主机间的大小端序不同，统一便于管理。

9. 首先大端序不需要将该4字节转化，然后传入小端计算机，转化为小端序。

10. 回送地址就是127.0.0.1,用于与本机通信。

    

## 第四章

先来说说协议栈（chatgpt）：协议栈（Protocol Stack）是计算机网络中的一种概念，它是指在网络通信中用于实现不同层次协议的一组协议的集合。协议栈中的每个协议负责处理特定层次上的通信任务，并按照规定的方式与上下层协议进行交互。TCP/IP协议栈包含多个层次，从底层到高层依次为物理层、数据链路层、网络层、传输层和应用层。

### 习题

1. 应用层，（TCP/UDP）层，IP层，链路层。 分别经过TCP 与 UDP层。

2. 链路层负责将数据转化为字节流进行传输，IP层负责寻址与路由。IP层建立在链路层之上，使用链路层进行传输。

3. 进行标准化设计有利于推广与开发。

4. listen

5. listen，使得套接字可以接受请求，并且设置请求队列，只有listen之后才能使用accept

6. 客户端通过connect在内核使用主机的ip地址，并随机分配端口。

   

## 第五章

### TCP原理

TCP的建立，使用，与关闭。

IO缓冲在每个TCP套接字中独立存在，并且在创建时自动生成，就算关闭套接字，也会继续传递输出缓冲，但是会丢失输入缓冲中的数据。同时TCP采用**滑动窗口**协议，并不会造成因缓冲区满而丢失数据的情况，会确保发出的数据是能够放入缓冲的。

#### 连接

**三次握手**，下面是三次握手的步骤：

1. 第一次握手：客户端向服务器发送一个请求，询问是否可以建立连接。这个请求包含了一些必要的连接参数，例如序列号（Sequence Number）等信息。
2. 第二次握手：服务器收到客户端的请求后，会向客户端发送一个同意连接的响应。这个响应包中也包含了服务器自己的连接参数，例如序列号、确认号（Acknowledgment Number）等信息。
3. 第三次握手：客户端收到服务器的响应后，会再次向服务器发送一个确认信息，用于告知服务器已经收到了它的响应。这个确认包中包含了客户端自己的连接参数。

当服务器收到第三次握手的确认信息后，TCP连接正式建立，双方可以开始进行数据的传输。

#### 使用

套接字是全双工的，能够同时输入输出数据。SEQ表示序列号，为同步消息，ACK为确认消息。对于SEQ与ACK, ACK = SEQ + 收到字节数 + 1.

#### 断开连接

FIN(FINISH)表示断开连接，需要经过**四次握手**，双方告知对方可以关闭连接。

### 习题

1. 如上所述。

2. SEQ表示序列包号，如果未接收到ACK信号，则表示传输失败，重发。如果接受到ACK信号，如果ACK = SEQ + 发送字节数 + 1 则发送成功，否则根据收到的字节数进行相应的处理。

3. write将数据放入输出缓冲，read将数据从输入缓冲读出。

4. 服务端传输时会发送请求，查明最多发送多少字节，最后根据该结果进行分段发送。

   

## 第六章 基于UDP

### UDP 与 TCP

UDP与TCP相比，缺少了流式控制，也没有ACK应答，这使得UDP不可靠（相对来说，数据丢失并不是那么频繁），同时速度比TCP要快。

这里再次强调IP层通过路由和寻址，将UDP包传输到主机，而UDP层通过端口号将包运输到相应进程。UDP适用于收发的数据量小而且需要频繁发送接受。

UDP的使用与TCP并不相同，只需要创建套接字就可以进行数据传输。并且一个进程只需要一个套接字就行。

同时UDP具有数据边界，发送与接受必须一一对应。

### 基于 UDP 的 IO函数

```c
#include <sys/socket.h>
ssize_t sendto(int sock,void* buf,size_t nbytes, int flags, struct sockaddr *to, socklen_t addrlen);
//参数分别为 UDP套接字描述符，缓冲，数据长度，可选项，信息结构体，结构体长度。
ssize_t recvfrom(int sock,void*buff,size_t nbytes,int flags, struct sockaddr* from, socklen_t *addrlen);
```

​	需要注意的是，在UDP中，不存在请求连接和接受连接的过程，只将提供服务的端称为服务端。同时，在UDP中第一次sendto时，如果没有分配相应地址，则会调用bind分配地址，持续到程序结束。

### 连接UDP与未连接UDP套接字

默认UDP都为未连接UDP套接字。

通过sendto发送数据时大致可以分为：向UDP套接字注册目标IP与端口号，传输数据，删除第一步的内容。

如果需要多次向同一处地方发送信息，则可以提前注册成为连接UDP套接字来提高效率（通过`connect`函数注册）。

### 习题

1. UDP不需要流式控制，也不需要ACK应答，正是这些使得UDP没有TCP可靠。

2. b,c,e

3. IP负责寻址与路由，将数据报送到对应主机，UDP负责根据端口号送至对应程序。

4. 传输大小小而且传输频繁。

5. 在第一次sendto若没有分配会自动调用bind绑定。

6. 如果需要多次对一个地方发送，则可以提高效率。

   

##  第七章 优雅地断开连接

如果直接使用close强硬断开连接，那么就会导致无法如之前所说互相通知是否能够关闭（因为会直接关闭所有通道）。可以使用**半开闭**进行更好地处理。

我们可以使用`shudown`函数来进行关闭：

```c
#include <sys/socket.h>

int shudown(int sock,int howto);
//howto 在 linux中可取  SHUT_RD, SHUT_WR, SHUT_RDWR分别断开输入，输出 ，所有流。
```

### 习题

1. 输入输出被控制着流动，形成了流，不能，UDP没有流控制。
2. 会使双方完全无法通信。
3. 关闭输入或者输出流。

## 第八章 域名与网络地址

### DNS

DNS(domain name system) 域名系统负责IP地址与**域名**之间的转换。

为了能够方便通往对应的IP地址，发明了**域名**作为助记符。在linux中通过`nslookup`指令得到系统的默认DNS服务器地址，`ping`可以获得域名对应的IP地址。

对于一个默认DNS服务器，如果查询不到相关ip地址，则会向上级DNS请示，直到请示**根DNS服务器**，最终返回结果到相应DNS服务器。所以说，DNS就是一个分布式数据库系统。

### 程序中域名的使用

通过下列函数将域名转化为ip地址

```c
#include <netdb.h>

struct hostent* gethostbyname(const char* name);

```

其中 `struct hostent`为：

```c
struct hostent {
  char *h_name; //官方域名  
  char ** h_aliases; //对应ip的其他域名
  int h_addrtype; //ip地址
  int h_length; //ip地址长度
  char** h_addr_list;  // 对应域名的多个IP
};
```

利用ip地址获得域名：

```c
#include <newdb.h>

struct hostent* gethostbyaddr(const char* addr, socklen_t len, int family);
```

### 习题



---

## 第九章 套接字的多种可选项

​	套接字是具有属性的，我们在之前都是使用套接字的默认属性，在`SOL_SOCKET`（通用）,`IPPROTO_IP`（IP层）和`IPPRPTP_TCP`（TCP层）分别有着相关的属性与设置。我们可以通过`getsockopt`与`setsockopt`来得到或者设置这些属性。

```c
#include <sys/socket.h>
int getsockopt(int sock,int level, int optname,void* optval,socklen_t*optlen);
//分别为所查询的套接字，协议层，可选项名，保存查看结果的缓冲，以及结果字节数。
int setsockopt(int sock,int level, int optname, const void* optval, socklen_t optlen);
//类似，成功返回0，否则返回-1.
```

例如`SOL_SOCKET`中的`SO_TYPE`表示套接字的类型，为TCP或者UDP，只能查询不能修改，因为套接字类型在被创建时就已经被确定。

`SO_SNDBUF` 与 `SO_RCVBUF`分别为`SOL_SOCKET`层关于输入缓冲以及输出缓冲的可选项。

### Time-wait 状态

`Time-wait`状态是一种重要的状态，它表现为先发起中断请求的主机在一段时间内无法使用之前的端口号（仍然被占用），需要在一定时间后才恢复。客户端与服务端都存在该问题，但是客户端是动态分配端口所以不会有直接的影响，但是服务端的影响是直接可见的，如果从服务端关闭服务，在接下来一段时间是无法bind的，因为该端口还未被释放。

可以通过设置`SO_REUSEADDR`为1，来将Time-wait状态下的端口号重新分配给新的套接字。

### Nagle算法

nagle算法运用在TCP，在传输一段数据前，必须收到上一组数据的ACK应答信号，否则会继续将数据堆放在输出缓冲。这种算法减少了传输数据所需要的数据包量，可以防止网络过载。但是在传输 大文件时，不适用Nagle会有更高的效率与速度。Nagle算法可通过`IPPRPTP_TCP`中的`TCP_NODELAY`设置为1即可。

### 习题

1. a
2. 传输大文件时禁用，在传输大文件时，每次传输基本都装满了输出缓冲，所以不需要Nagle的延迟传送。





## 第十章 多进程服务器端

几个并发服务器的模型：

- 多进程服务器
- 多路复用服务器
- 多线程服务器

在linux中可使用ps指令查看进程信息：

```shel
ps : 显示当前窗口进程信息
ps -e : 显示所有进程信息
ps -f : 显示详细的进程信息
ps -ef --forest : 显示树状进程信息
ps -u username : 显示指定用户的进程信息
ps au : 显示以用户为主的所有进程的详细信息
```

### 进程与僵尸进程

僵尸进程就是那些执行完任务，但是仍然占据着资源的进程。

子进程通过exit参数或者return的返回值会返回给操作系统，操作系统不会立刻结束该进程，需要父进程主动获取该值，并结束该进程。

有两种方法结束僵尸进程，分别为使用`wait`,使用`waitpid`。

```c
#include <sys/wait.h>

pid_t wait(int*statloc);
pid_t wait(pid_t pid, int*statloc,int options);
//等待终止的pid，状态，可选项（选择头文件中的常量WNOHANG，即使没有终止的子进程也不会阻塞，而是返回0退出函数）
WIFEXITED(statloc) //如果进程正常终止则返回真
WEXITSTATUS(statloc) //返回进程终止的返回值（如果正常终止）
```

当使用wait时，它会阻塞进程直到有进程终止，所以需要谨慎使用，关于`WIFEXITED`则表示 进程是否正常退出，如果正常退出，`WEXITSTATUS`表示进程结束的返回值。

当使用waitpid时，如果pid为-1，则等待任意进程，使用常量WNOHANG来不阻塞进程。

### 信号signal

信号机制之前在操作系统中有所涉及。

几种重要的信号:

- `SIGALRM`：到了alarm函数注册的时间
- `SIGINT`: 输入Ctrl + C
- `SIGCHLD` : 子进程终止

```c
#include <unistd.h>

void (*signal(int signo,void(*func)(int))(int));
//信号注册函数

unsigned int alarm(unsigned int seconds);
//如果参数为0，则取消之前的预约。
//如果未注册函数，则终止进程，不做任何处理。
```

​	signal函数在UNIX类系统中可能不大相同，但是sigaction是全都相同的，所以可以用sigaction代替signal，这样更稳定。

```c
#include <signal.h>

int sigaction(int signo,const struct sigaction* act, struct sigaction* oldact);

struct sigaction {
  void (*sa_handler)(int);
  sigset_t sa_mask;
  int sa_flags;
};
```

### 基于多任务的并发服务器

原理类似于操作系统课程中的shell，通过向服务端发送请求，服务端fork出子进程进行处理。

关于套接字，在fork中会复制文件描述符，但是套接字不属于进程，而是属于操作系统，这两个相同的文件描述符指向了同一个套接字，只有当指向该套接字的所有文件描述符都被关闭，该套接字才会被关闭。

### 分割TCP I/O程序

将客户端的输入输出分割成不同进程的任务，这样可以简化程序，提高效率。

### 习题

1. c
2. a,c,d
3.  略
4.  进程执行完任务，但是父进程并没有将他结束掉，产生了僵尸进程，使用信号机制与wait等函数进行处理。
5. 略

## 第十一章 进程间通信

