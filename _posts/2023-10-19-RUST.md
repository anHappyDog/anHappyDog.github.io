---
title: RUST
date: 2023-10-19 22:41 +0800
author: lonelywatch
categories: [RUST]
tags: [RUST]
toc: true
---

RUST就是RUST,就像CPP就是CPP,C就是C以及我这句话一样。RUST只需要RUST就好了。

## 安装

访问 https://www.rust-lang.org/zh-CN/tools/install 安装rust。

其中rustc是rust编译器，rustup是rust的工具链管理器，用来对rust进行相关操作。cargo是Rust的构建系统和包管理器，可以使用cargo来创建一个新项目（基本用这个）。

## cargo

下面是cargo的一些指令：

```shell
# 创建项目
cargo new <projectName>
# 构建项目
cargo build [--release]
# 编译(需要的话)并运行
cargo run
# 检查是否可编译通过且运行
cargo check
```

对于cargo创建的项目文件夹，一开始包含这么些东西：

- src文件夹
- .gitignore文件
- Cargo.toml文件：RUST项目的配置管理文件。

在build后，会生成target文件夹，其中debug文件夹存放了可执行文件。

TOML（Tom's Obvious, Minimal Language）是一种被设计用于配置文件的简单、易读的格式。它通常以".toml"为文件扩展名

下面是一个toml文件：

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

```

其中`package`指明了所用的rust版本以及项目名，`dependencies`指明了项目所用的包`crate`。

事实上，crate包可以分为库crate和二进制crate（不可单独执行与可单独执行）。

## 从猜数字开始

rust中存在着标准库这一概念（`std`），其中一少部分被内置在rust本身中，这一部分被称为`prelude`,其他的库可以通过使用`use`导入。使用库中内容与cpp一致，使用域作用符`::`。

还有一个概念是 **可变与不可变**（mutable and unmutable），事实上rust默认变量是不可变的，如果需要让他可变，就必须在定义时使用`mut`来显式声明其可变性。（使用let 定义变量）

关于输出的话，字符串中存在**占位符** `{}`的概念，使用占位符来进行字符串插值。

还有一个概念就是 **Result**，类似于 **try-catch**机制，用来处理错误。Result分为通用Result以及特化Result，其中有Ok和Err成员分别表示成功与失败的值和原因。 类似于catch的`expect`方法在result返回err时就会调用该方法。

关于引用外crate包，只需要在toml文件中的dependencies中显式添加引用的crate包名以及版本号，类似于：

```toml
rand = "0.8.3"
```

## 变量，可变性与常量

使用`let`定义变量，可在定义时使用`:<type>`来指定变量类型。

使用`const`定义常量，必须在定义时使用`:type`指定变量类型。

变量默认是不可变的，使用`let mut <var>`来指定变量可变。

RUST是静态类型语言，所有变量的类型在编译时已经确定。

变量可以被**遮蔽**，也就是重定义。

### 标量类型

标量类型表示单个值。RUST有4个基本标量类型：整型，浮点型，布尔型和字符。

#### 整数

对于整数有`[iu][8|16|32|64|128]`等类型。支持在数字后添加数字类型，类似于`110u16`,同时，字面量也支持二，八，十，十六进制。

#### 浮点数

类型有`f[32|64]`,默认f64.

#### 布尔

类型为`bool`,取值为：`true|false`。

#### 字符

RUST使用Unicode，所以一个字符占据4字节。

### 复合类型

RUST有**元组**和**数组**。

#### 元组

类似于python中的元组，可存放多个不同类型值，但是长度固定。需要使用**模式解构**的方式来获取其中的值。

```rust
let tup:(i32,i64,bool) = (1,2,false);
```

这里也可以不指定类型。

#### 数组

多个相同类型的值组合的类型，并且具有固定长度。

使用`[]`中用`,`将若干值隔开来写入数组。

使用索引来访问数组元素，使用`[]`。

---

---

rust是**基于表达式**的语言。一个很有意思的点就是，代码块被看作是表达式，但是赋值以及函数定义这些是语句。

---

---



## 函数

使用`fn`来声明函数，并且rust函数使用**蛇形命名法**，一个函数声明可以为：

```rust
fn func(x:i32,isOk:bool) -> i32{
    5;
}
```

## 注释

使用`\\`单行注释，除此以外还有 文档注释，类似于Java doc。

使用`\\\`来表示文档注释，并且文档注释要在需要注释的代码之前。可以在注释中使用Markdown来格式化文本。

## 控制流

### 条件

使用if，else if， else来表达条件（不需要圆括号，但是需要大括号，其他和cpp相同），需要注意在RUST中并没有其他类型隐式转化成bool的机制。

并且if表达式（并不是语句），所以可以作为右值。

### 循环

RUST使用`loop`,`while`和`for`进行循环(这三个也是表达式，可以赋值)。

loop就像`while(true)`,就像`loop { state }`并且可以在使用break时返回值。

while循环就像cpp中的while，for循环使用的是for-in

## 所有权

为什么rust比c++安全呢？因为rust就是rust，就像c++就是c++，rust只需要rust就好了。

RUST通过**所有权**来进行内存管理，这样编译器会在编译时就进行一系列的检查，所以也不会像GC那样减慢程序。

### 所有权规则

- RUST中的所有制都有一个被称为 其 **所有者** 的变量。
- 值在**任一时刻**都只有**一个**所有者。
- 当所有者（变量）离开作用域时，这个值就被废弃。

事实上，当变量离开作用域时，就会被调用drop方法，这是一种叫做**资源获取即初始化**（Resource Acquistion Is Initialization（RAII））

对于栈上内存来说，这是很显然的事情，但是对于堆来说，并不是十分显然。

String存放在堆上，其组织形式大致为 栈上存放指向堆中内存的指针，长度以及容量。RUST中存在着**移动**的概念，当把一个String赋值给另一个String时，确实会发生类似于**浅拷贝**的事情（即只把栈上的东西赋值过去），但是在同时，RUST会认为赋值用的String不再有效（否则，会对同一个堆上内存调用两次drop，学名是**二次释放**），不再有效也意味着，这个值已经不能使用了。

这就叫做移动，而非浅拷贝。

如果需要拷贝堆上内存的话，可以使用clone通用函数。

对于只有栈上内存的类型，拷贝是会完全拷贝的，RUST中有**Copy Trait**的概念，如果一个类型实现了这个东西，那么再把旧变量赋值给新变量后旧变量仍然可用（但是不允许实现了**Drop Trait**的任何东西使用CT）。

---

总的来说，就是一个变量（如果有堆上内存的话）一旦离开所在的作用域，就会drop掉，就算是通过函数参数传递，也是一样，但是可以通过函数的返回值来**传递所有权**。

### 引用

如果需要在函数中使用某一值，但是又不想要丢失掉所有权，就可以使用**引用**。

通过`&`来使用引用。函数参数可以这么写：`(x:&String,y:&i8)`。

与`*`相反的操作就是解引用。

书中把创建引用的行为称为 **借用**（并没有所有权，所以也不用drop）。

引用默认是不可变的，所以也需要像定义时那样添加mut可变标志，`&mut <var>`。来表示引用可变。（**很重要的一点是对一个变量来说，不能同时拥有可变引用和不可变引用**，就是说可变引用和不可变引用的作用域不能交叠，只能有一个可变引用或者多个不可变引用）。

另外,RUST也不会让变量在引用失效前就drop掉（引用必须总是有效）。

### 切片

一种不同类型的引用是`slice`切片。（它也没有所有权）切片的使用与pyhton的切片使用相同。同时使用&符号。   

一个特殊的slice就是String 的字符串slice，在切片`[]`符号中使用Range，在Range中使用第一个元素和最后一个元素时，可以省略第一个值或者第二个值（或者全部省略来表示所有的值）。

同时，字符串slice的类型声明写作`&str`。

对于其他类型的切片也是类似，其类型声明为`&[<type>]`。

## 结构体

类似于元组，可是结构体需要给各部分数据命名。

定义结构体需要使用`struct`关键字，并且为整个结构体提供一个名字。然后在大括号中定义每一部分数据的名字和类型（这被称为 字段）。

```rust
struct test{
    field1:i32,
    field2:bool,
    field3:String
}
```

创建结构体实例时，需要使用结构体的名字，在其后的大括号中使用键值对的方式提供字段(`key:value`)。（这也是一个表达式），（一个很有意思的写法就是：如果初始值变量与key值相同，那么可以省略`key:`）。

使用结构体可以使用`.`操作符。

### 结构体更新语法

使用结构体更新语法来使用已经存在的实例来创建新的实例。

语法为：

```rust
let newStruct = structName {
  //init values that need changed,
   .. oldStruct
};
```

需要注意 该语法***移动***了（Drop traits）数据，所以（实现了Drop traits的）所有权会发生转移。

旧结构体必须要放在最后，但是前面需要更新的值可以随意摆放在其前面。

### 元组结构体

没有字段名的结构体就是元组结构体，可以理解为命名的元组。

### 类单元结构体

没有任何字段的结构体就是类端元结构体。

创建实例时，不需要使用花括号和圆括号。

**生命周期**是一个很重要的概念，但是会在后面才会详细提及。

---

finishedTime：2023/10/21 21:02 

受限于自身状态以及任务，今天只能到这。

---

### 结构体的打印与输出

println!宏默认使用Display trait来输出信息给终端用户，打印输出结构体需要使用Debug Trait，在结构体定义上添加`#[derive(Deubg)`即可，然后使用`{:?}`在字符串中插值输出结构体，如果需要格式方便观察，可以使用`{:#?}`用于结构体打印自动换行。

---

除此以外也可以通过使用`dbg!`宏来进行内容的调试输出，该宏会先输出文件名和行号，然后输出内容，并且会**返回传入参数的所有权。**

### 方法

从某个时候，我就把方法和函数混淆了，不过其实也差不多，，，

----

方法需要在结构体的上下文中被定义。类似于

```rust
struct name {
    
}
impl name {
 	fn func(&self) {
        
    }   
}
//&self 也可以写成self : &Self
```

其中使用`impl`来创建一个结构体上下文，在其中定义方法。

`&self`取决于是否需要传递所有权，如果不需要就可以单纯使用`&self`，否则也可以用`self`。

可以使用多次`impl`来使用命名空间。

### 关联函数

关联函数类似于c++中的类方法，作用与整个结构体而非单个实例。

关联函数的定义与方法的定义类似，需要在结构体命名空间中定义,只是参数中不能传递`self`，其他和普通函数相同。

通过作用域运算符`::`来使用关联函数，类似于`Student::name()`

## enum与Option

### enum

Rust中也存在着枚举，除了struct意外，enum也是一种自定义类型。一个enum类型包含若干成员，（Rust的特性是**可以为每个成员附加任何变量**，并且也像struct那样可以定义命名空间和方法）。类似于：

```rust
enum IpAddr {
    V4(i8,i8,i8,i8),
    V6(String)
}
```

enum通过`::`来使用其成员，通过imple来定义命名空间，类似于：

```rust
impl IpAddr {
    
}
let t = IpAddr::V4(1,2,2,3);
```

### Option

由于所有权机制，上面提到的类型在使用时都是有效的，但是有时也会有需要判断是否为空置的情况，Rust中不存在控制，而是使用`Option<T>`作为代替。Option其实是一个枚举类型，并且使用了泛型参数，使得能够包含任意类型，定义如下：

```rust
Option<T> {
    Some<T>,
    None
}
```

代表着，存在某个类型的值和不存在。并且使用其中成员时，需要先处理可能为空的情况。

Option在rust中很重要，并且被编译进了prelude中。

### match

match是rust中的一个控制流运算符，类似于case，顺序地匹配match中的模式，并执行匹配成功的代码块，类似于：

```rust
enum SomeEnum {
    ...
}

match someEnumInstance {
    type1 => {},
    type2 => {},
    ...
}
```

match与enum结合会形成**绑值匹配**的机制，如果enum成员携带了一定数据，需要在模式中显示列出，也可以在列出后使用。

同时，rust中的match是穷尽的，意味着match必须使用所有可能的模式。

match也可以使用通配符（用一个变量名来代替具体的值）。使用通配符时必须将通配符放置最后（顺序匹配），如果不想使用匹配到的值时，可以使用`_`代替匹配变量。

这样就可以这么写，放到最后来滤掉不想执行的情况：

```rust
_ => ()
```

### if let

if let就是match只匹配一种模式的语法糖。

```rust
if let pattern = val {

} else {

}
```





----

### 开始

使用`cargo new  <projectName>`来创建新项目。注释和c++相同。

rust的入口文件为`main.rs`，入口函数为`fn main() {}`（**使用 fn定义函数，参数类似于`<name>:<type>`，返回类型类似于`fn <name>()-> <type>`，返回值为函数中的表达式（不加分号即为表达式）。**

### 类型

rust是**静态类型**语言。

标量类型有： 整型，浮点型，布尔型和字符。`i`,`u`,`f`,`bool`,`char`。

复合类型有：元组tuple和数组array。

 ### 变量

变量分为可变与不可变（默认不可变）。

通过`let`定义变量（rust会自动推断变量类型）。

通过`let mut` 定义可变变量。

### 常量

使用`const`定义常量。

### 输入

1. 命令行参数

使用`std::env::args`来获得命令行参数。

2. 环境变量

使用`std::env::var`来使用环境变量。

3. 标准输入

使用 `std::io`的stdin来输入。

4. 文件读取

使用`std::io::File`或者是`std::io:Read` 读取文件。

5. 网络

使用`std::net` 来进行网络通信。

### 输出

1. 标准输出

使用`println!`和`print!`或者是`eprintln!`与`eprint!`来输出标准输出或者是标准错误。

2. 文件输出

使用`std::fs::File`与`std::io::write`来写入文件。

---

### 宏

