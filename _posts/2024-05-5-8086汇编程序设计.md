---
title: 8086汇编程序设计
author: lonelywatch
date: 2024-05-5 15:14
categories: [汇编]
tags: [X86,汇编]  
---

# 8086 

8086是Intel最早推出的X86  16位CPU之一，使用20位地址总线，寻址空间为1MB,共有14个寄存器，其中包含8个通用寄存器，4个段寄存器，1个PC寄存器，1个PSW寄存器。

> 注: 如下内容来自于熊老师的X86汇编，老师讲课认真负责，待人温和，是位很好的老师，下面是对老师讲授内容的总结和归纳。 

## 寄存器

### 通用寄存器

通用寄存器有`AX,BX,CX,DX,BP,SP,SI,DI` 共8个寄存器。即使说是通用寄存器，大多数通用寄存器仍然具有使用规范，包括：

- 只有BX和BP用作基地址寻址，因此这两寄存器又被称为基址寄存器，只是BX默认相对于DATA段，而BP默认相对于堆栈段寻址。
- CX用于各种循环指令和重复指令中，根据PSW中的ZF标志位决定加减。
- AX常被用于乘除法的第一个操作数，DX被用来作为AX的高位，在16x16位乘法中`MUL SRC`表示`AX * SRC`,结果为`DX:AX`总计32位；在32/16位除法中，`DIV SRC`表示`DX:AX`表示的32位数字除以16位`SRC`。
- SI与DI寄存器常被用于串指令中，用于表示串的当前位置。
- SP寄存器表示堆栈栈顶，BP用于非叶子程序参数传递。

需要注意前面四个16位寄存器更多被称为数据寄存器，每个寄存器可以分为2个对应位置的高八位寄存器和低八位寄存器，比如AX可分为高AH和低AL寄存器；后四个16位寄存器更多被称为指针寄存器，且不可像之前那样被分割。

### 段寄存器

然后就是4个段寄存器`SS,DS,CS,ES`分别表示堆栈段，数据端，代码段和附加段；附加段主要用于串指令配合`SI`与`DI`使用。需要注意在8086中每个段寄存器都需要在程序开始时显式使用指令进行初始化，需要注意段寄存器不能用立即数初始化。

### PC寄存器与PSW寄存器

PC寄存器（或者说是IP寄存器，我更喜欢称为PC寄存器）用于表示当前指令地址；PSW寄存器是一个标志位寄存器，用于存储指令在执行过程中产生的各种标志，包括溢出，进位，负数，中断，异常等。

## 指令集

8086的指令采取`OP [DST[,SRC]]`的形式，并且是不定长的CISC指令集。

主要可分为 数据传送指令，逻辑指令，算数指令，串指令 ，循环控制指令以及中断相关指令。

### 数据传送

最常使用的是`MOV DST,SRC`指令，用于将数据复制到另一个地方，这里需要注意传送双方的位长匹配问题，尤其是**立即数向内存之间**的传递,比如`MOV S,0H`就应该改成`MOV WORD PTR S,0H`,需要确定所使用内存的字长，并且传送时也应该注意数据的大小不能超过字长。

#### 逻辑指令

主要有`AND,OR,XOR,NOT`，指令格式都为`OP DST,SRC`。

### 算数指令

主要有`ADD,ADC,INC,DEC,SBB,SUB，NEG`,其中`INC <T>`,`DEC <T>`分别表示进一和减一。ADD,SUB不带进位和借位，而ADC与SBB则带进位，也就是操作时会带上标志位`CF`。NEG指令用于取补码。

### 串指令

串指令主要用于操作串，指令主要有`MOVS[W|B],LODS,STOS，LEA,`

### 跳转与循环指令

跳转指令主要分为无条件跳转和有条件跳转。

无条件跳转使用`JMP <ADDR>`。

有条件跳转根据PSW中的标志位决定是否跳转，主要有`JZ/JE, JNE,JAE,JBE TEST`。x86的一个特点是有循环指令，包括`LOOP,LOOPE,LOOPNE`，`LOOP <label>` 会将CX - 1,如果不为0则跳转到label处。

`CALL <proc>`用于调用子程序，`RET <2N>`用于从子程序返回并修复栈。

### 中断指令

通过`INT <X>`传入中断号进入中断，通过`IRET`从中断返回。

## 寻址方式

对于数据的寻址方式，总共有6种：

- 立即数寻址
- 直接寻址
- 寄存器直接寻址
- 基址变值寻址
- 寄存器相对寻址
- 间接寻址

对于地址的寻址方式，总共有4种:

- 段内直接跳转
- 段内间接跳转
- 段间直接跳转
- 段间间接跳转

## 程序结构

一个8086汇编程序主要有代码段，数据段，堆栈段组成，类似于

```assembly
DATA_S_NAME SEGMENT PARA
	T1 EQU 1H
	T2 DB 0FFH
	T3 DW 100
	DB 10H
	T4 DD 100H DUP(0)
DATA_S_NAME ENDS

STACK_S_NAME SEGMENT PARA STACK
	STACK_AREA DW 100H DUP(?)
	STACK_BTM  EQU $ - STACK_AREA
STACK_S_NAME ENDS

CODE_S_NAME SEGMENT PARA 
	ASSUME CS:XX,DS:XX,SS:XX,ES:XX
MAIN PROC FAR
	...
MAIN ENDP
CODE_S_NAME ENDS
	END MAIN
```

- 使用`SEGMENT`与`ENDS`定义段，最后在代码中对段寄存器初始化。`PARA`让段能够256字节对齐，还有BYTE,PAGE这些选项。

- 使用`END MAIN`来指定程序入口为MAIN子程序。
- 通过`PROC`与`ENDP`定义子程序，如果使用`FAR`为段间定义，否则为`NEAR`则是段内定义。

## 子程序与宏定义

子程序和宏相比总的程序占用空间更小，但是宏不需要使用堆栈。

### 子程序

通过`PROC`与`ENDP`来定义子程序，通过`CALL`调用子程序，通过`RET <2n>`从子程序返回并修复堆栈。可以使用堆栈来传递参数，比如在调用前使用堆栈存放参数，在子程序中使用BP保存传入时的SP寄存器，通过BP来访问参数，最后通过RET修复堆栈，这一过程需要注意BP的保存和修复。

### 宏

通过`MACRO`与`ENDM`来定义宏，宏可以传递参数，如果定义时给定形参，则使用时必须给定实参。

## 结构体

使用`STRUC`与`ENDS`来定义结构体数据结构，使用类似于定义段内变量的方式定义结构体的成员变量，使用时使用`.`操作符号。