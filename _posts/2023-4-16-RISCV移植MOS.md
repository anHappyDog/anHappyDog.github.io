# RISC-V移植MOS

将MOS从MIPS32 r3000移植到RISC-V架构的virt上，并且支持原有SHELL。

## 环境配置

基于windows下的wsl2进行开发，使用如下工具：

- OpenSBI: RISC-V的Bootloader

- gdb-multiarch: 用于调试内核

- bintuils-riscv64-unknown-elf: RISC-V的交叉编译工具

- qemu-system-riscv32： QEMU模拟器


## LAB1 内核启动与printk实现

-​	修改内核链接文件，内核开始地址为：`0x80200000` ,结束于`0x80600000`。

​-	修改编译内核用的Makefile文件和引用的mk文件，其中主要修改的部分为 编译 和启动需要的工具，以及相关变量。

​-  通过调用相应ecall，实现输入和输出以及halt。

## LAB2 MMU设置和内存管理

- ​RISC-V开启MMU之后S态与U态都需要通过访问页表访存，而TLB则是通过硬件维护，通过`sfence.vma`来对相应TLB项进行刷新。

- RISC-V页表项结构与MIPS不同,将页表地址填入`satp`寄存器中，设置映射模式为`SV32`正式开启MMU。

​在修改完成后，通过相应测试。

## LAB3 例外处理和进程管理。

​- 在RISC-V中，`sie`和`sip`寄存器控制S态响应外部中断，通过修改相应位置来开关中断。

​- 通过设置该寄存器开启时钟中断，通过SBI设置中断需要的时间。

​- 异常处理需要进行上下文的切换，而切换前可以是U态也可以是S态，需要对mips的上下文切换机制进行相应的修改。利用`sscratch`寄存器保存相应栈的值（同时如果sscratch为0，则之前状态为S态，否则为U态，因为存储了S态的栈值），同时增加对SR寄存器的保护和修复（stval，sepc,scause，sstatus,sscratch(栈值)）。修改上下文对应的结构体。

​- 根据RISC-V的异常种类建立异常向量表，`stvec`寄存器记录了S态和U态异常处理程序的入口，将异常处理模式设置为直接入口模式以开启异常处理。

- 进程管理与MOS在MIPS中并无太大出入。

​完成后通过相应测试。


### LAB4 系统调用和fork

-  实现用户态只读页表的COW机制。只有当第一次读取该只读页表时，才会映射其中。

- 实现fork与COW用户页，与MOS在MIPS中的实现并无太大出入，只是需要利用RISC-V在页表项中的保留位实现`PTE_LIBRARY`和`PTE_COW`。

​完成后通过相应测试。

### LAB5 文件系统

- 使用VIRTIO代替MOS在MIPS中使用的ATA硬件协议，这里使用`virtio-mmio`，导出virt机型的设备树文件，发现VIRTIO设备的MMIO地址区域，根据VIRTIO文档实现扇区读写。

- VFS与FS层与MOS在MIPS中的实现并无太大出入。

完成后通过相应测试。

### LAB6 实现简易shell

- 这里并不需要太多的变化，按照MOS原有实现即可。

​	根据mips中的管道来实现管道，同时模拟实现shell，不同的是spawnl需要对不定参数进行读取，而非直接作为参数进入spawn中。


--以上为我移植任务的实践报告，在过程中由于不熟悉，以及知识水平的欠缺，实现的并不好，站在后来人的角度上，都有更好的实现办法。--

> 2024/06/10 重新修正，简洁措辞，看着一年前的自己，情绪有点复杂，当时的我半知半懂，即使现在的我也是如此，当时的我写下这些的时候一定十分兴奋，至少我的记忆中是这样的，因为自己终于遇到了喜欢的事情，这份兴奋太过猛烈，让我现在都有些难以忘记。