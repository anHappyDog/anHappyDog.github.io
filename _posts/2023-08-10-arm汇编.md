---
title: arm汇编
author: lonelywatch
date: 2023-08-10 10:05
categories: [汇编]
tags: [OS,汇编,ARM]
---

# ARM

之前riscv只是浅尝辄止，这次是真的需要好好了解了。相比于了解其架构，我还是想先去看看汇编。

```
//官方汇编文档
https://developer.arm.com/documentation/ddi0602/2022-09/Base-Instructions/ABS--Absolute-value-?lang=en

```

### 寄存器

对于aarch64来说总共有31个64位通用寄存器，从x0到x30（如果表示成w0到w30则看作为32位寄存器）。

除以以外，还有

- 32个向量寄存器v0-v31（仅限于ARM64，128位）。
- 32个单精度浮点寄存器s0-s31(32位)，32个双精度浮点寄存器d0-d31(64位)，这64个寄存器为标量寄存器。

还有一些辅助寄存器（FPSCR,Float-Point Status control register）。比如说 

- FPCR(浮点控制寄存器)用于控制浮点数运算的舍入模式等。
- FPSR（浮点状态寄存器）用于存储浮点数的运算状态。 
- NZCV(条件标志寄存器)用于存储比较和逻辑操作。
- ESR_EL1(Exception Syndrome Register，EL1，异常综合寄存器)，存储异常发生的异常信息和原因。

---

关于向量寄存器与标量寄存器：向量寄存器容量更大，能存储多个值，同时进行运算，提高并行性。多用于SIMD(single instruction， multiple data)指令。

---

对于A64指令来说，第一个操作数基本都是目标寄存器。

```assembly
@ mov 用于设置寄存器中的数据。 将 后面的值赋给reg1
mov <reg1> <reg2>|<imm>
@
```

### 算数操作

加减乘除位运算

```assembly
@加减乘，有符号和无符号除
add|sub|mux|sdiv|udiv <dest>, <reg1>|<imm>, <reg2>|<imm>
@位运算
@ 逻辑左移,右移,算数右移
lsl| lsr | asr <dst> <reg1>|<imm> <reg2>|<imm> 
@ 逻辑运算 与，或，抑或
and | orr | eor  <dst> <reg1>|<imm> <reg2>|<imm>
@非 
not <dst> <reg>| <imm>
```

### 比较和跳转

比较有些特殊，它将结果保存在NZCV寄存器中。

```assembly
@比较reg1和reg2如果reg1 == reg2 则设置NZCV中Z（Zero）标志位
@如果小于0，则设置NZCV中N（Negative）标志位
@其他V（Overflow）表示signed算数结果溢出
@ C(Carry)表示unsigned算数结果不匹配（感觉和V差不多?）
cmp <reg1>, <reg2>
```

关于NZCV寄存器，高32位和低28位保留全0，NZCV标志位分别对应着[31:28]。

对于特殊寄存器，读取通过`mrs`（Move to register from special register）指令。写入通过`msr`（Move register to special register）指令。

```assembly
@ 类似于这个
mrs <xt>, NZCV
msr NZCV, <xt>
```

跳转可分为无条件跳转和条件跳转

```assembly
@ ret 返回上层函数
ret
@ B 无条件跳转到label
b <label>
@ BL 无条件挑战并且将返回地址存放到链接寄存器中
bl <label>
@ BR 无条件跳转到寄存器中的地址
br <xt>
@ BLR 跳转到寄存器中的地址，并将返回地址保存到链接寄存器
blr <xt>
@@@@@@
@ B.<condition> 为条件跳转，常见有GT,LT,EQ,NE,GE,LE等
@ 条件跳转需要配合使用上面的比较语句，如
cmp x0, #0
beq label1
```



### 内存与寄存器

arm作为risc型架构，是不能直接操作内存的，需要内存与寄存器进行交互。

```assembly
@ (load register)读取内存 将address 的64位数据读入reg
ldr<sign><size> <dest>, [<address>]
@ ldr(s|)(b|h|w|)
@@@
@ (store register)存入内存，将reg中的64位数据存入address
str<size> <src>, [<address>]
@str(s|)(b|h|w|)
```

ls只操作部分数据时涉及0扩展和符号扩展。

关于address，有几种模式：

```assembly
@ Base 只使用寄存器存储的地址 
[reg]
@ Offset 地址为reg中的基址加上offset
[reg, #offset] 
@ Pre-Index 使用该模式reg的值会被更新为reg + offset
[reg, #offset]!
@ Post-Index 使用reg的基址，随后reg被更新为reg + offset
[reg], #offset
```

---

LS还有`LDP`和`STP`指令(针对Pair,一次操作两个寄存器),address对于reg的类型是自适应的：

```assembly
LDP|SDP <reg1> <reg2> [address]
```







### 伪指令

```assembly
@ .global <symbol> 使得符号为全局符号
@ .type <symbol> <kind>  设置符号的种类，常见的有@function (函数), @object (对象), @gnu_indirect_function (GNU间接函数)
@ .align <2pow> 字节对齐为2^<2pow>
@ .data 表示接下来的指令存储在数据段
@ .text 表示存储在代码段  (上面两个结合 .section使用)
@ .asciz 创建一个带有0的字符串
@ .word 创建若干个字
@ .byte 创建若干比特 （用法 .byte <byte1> <byte2> ...）
@ .space 创建若干字节 (和.byte用法不同 ,用法为 .space <byteCount>)
@ .include 引用其他文件
@ .macro .endm 定义宏指令
```

### 汇编与C的函数调用

在c中调用汇编函数只需要使用`extern`关键字声明函数。在汇编中调用c函数需要使用`.extern`声明函数标签。

### 函数调用规范（PCS）

1. 将前若干个（最多8个）参数（整型或指针地址）依次存储在x0-最多x7寄存器中，多余参数通过栈传递。（如果是32位则为w寄存器）

2. 在函数中x0-x15可以随意使用，而x16-x28则需要保存到栈内(callee-saved)，最后函数返回时修复。其中XR(x8)为间接结果寄存器（如果返回结构体，指向调用者分配的内存？），FP(x29)，LR(x30)链接寄存器保存返回地址，IP0(x16),IP1(x17),PR(x18).

3. 返回值存放在x0和x1中。

4. 在函数过程中，x29,x30,sp寄存器被用作栈帧指针和返回地址保存。

   x19-x28,x8-x18,v0-v7在函数内部可自由使用。

5. 函数调用时x29寄存器会用作栈帧指针，指向当前函数栈帧底部，而sp寄存器则指向当前栈的顶部。

### 系统调用

系统调用使用`svc`（supervisor call）,`hvc`(hypervisor call),`smc`(secure monitor call)指令进行系统调用。

-  svc:从EL0产生指向EL1的异常。
- hvc:从EL1产生指向EL2的异常。（EL0不可用）
- smc:从EL2产生指向EL3的异常。（EL0不可用）

使用系统调用需要根据系统调用表，填入合适的参数。

特殊的是，如果产生中断指向的特权级不高于当前的特权级，则在本特权级进行处理。

