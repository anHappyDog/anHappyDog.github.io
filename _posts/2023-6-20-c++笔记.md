---
title: c++笔记
author: lonelywatch
date: 2023-6-20 00:14 +0800
categories: [c++]
tags: [c++]
---

​	虽然之前有断断续续地用过cpp，但是一直没有系统地学习过，导致用完就忘，现在难得有时间，想要好好学学cpp，毕竟我最喜欢的语言就是c和cpp了。

​	初始化，在C11中，很多变量的初始化可以省略`=`。

### 类

### 类内常量

在类中使用`static`修饰变量，作用域变成了整个类。

在c11中，如果两个enum中的元素名字相同，需要通过在enum后声明class，即`enum class xx{};` 来区分，使用时也需要通过class名以及作用域解析符`::`来进行使用。

### 重载

重载运算符可以在使用类时方便地表达某种功能。在对象调用被重载的运算符时，其实省略了如`.operator`此类。

同时，**友元**分为三类，分别为友元函数，友元类，友元成员函数，这里只讲第一类，友元函数。友元是让非类成员的元素具有和该类成员一样访问权限的机制。在重载一些二元运算符加减乘除时，运算符的调用者可以是标准类型，所以这种重载并不在类中，但是又必须访问类中元素，所以必须是友元。使用时，只需要在类中声明`friend`即可。最常见的友元重载就是重载<<运算符。

### const

const对于成员函数可以修饰返回值，参数，以及函数（不能修改类成员变量）。当修饰返回值时，该返回值不能充当可修改的左值，同时可以避免拷贝，提升效能，当修饰参数时，不能修改参数（指针则不能修改地址，但可以修改内容）。

### 继承

继承分为：公有继承，保护继承与私有继承。同时c++没有super，可以调用基类的构造方法等。

多态与继承有关，多态的定义为：程序根据不同的对象类型调用不同的函数。

- 公有继承：会继承基类中的私有成员，但是只能通过基类中的公有方法访问使用。派生类不能使用基类的私有方法。公有继承代表 `is-a`的关系，而非`has-a` 或者`is implemented as a ` 的关系。关于 多态公有继承，这里有两种方法：
  - 在派生类中实现基类方法
  - 使用虚函数(virtual)

​		为什么会有虚方法：如果传入方法的参数为引用或者是指针而非对象，则被调用的方法会被确定而非多态，需要使用virtual 修饰被调用方法（对于基类和派生类两个类，只需要在基类中声明），使得多态被实现，同时，在继承关系中析构函数必须是**虚**的，否则会导致调用错误的析构函数而出现问题。

​		关于虚方法的实现：多态分为动态多态和静态多态，分别在运行时和编译时确认。每一个类都有一个虚函数表，其中是指向虚函数的函数指针，该类的内存中有一个指向虚函数表的指针，调用虚函数时，通过该指针来调用相应的函数。

对于这么两个类：

```c++
#include <iostream>

class Base1 {
public:
    virtual void doSomething() { std::cout << "Base1\n"; }
};

class Derive1 : public Base1 {
    void doSomething() { std::cout << "Derive1\n"; }
};

class Base2 {

};

class Derive2 : public Base2 {

};

void test1(Base1* t) {
    t->doSomething();
}


int main() {
    using namespace std;
    Base1 base1;
    Derive1 derive1;
    test1(&base1);
    test1(&derive1);
    //printf("base1 size is %d,int* size is %d\n",sizeof(class Base1),sizeof(int*));
    printf("%x\n",*((int*)(&base1)));
    printf("%8x\n",*((int*)(*(int*)(&base1))));
    void (*addr)() = (void(*)())(*((int*)(*(int*)(&base1))));
    addr();
    return 0;
}


```

 如果没有virtual修饰父类中的doSomething，那么test1输出的结构都会是Base1，而非Derive1。同时如果没有virtual，sizeof(class Base1)将会等于 1， 在有virtual修饰方法的情况下，则 sizeof(class Base1) 将会等于8，成员方法是不会占据这段内存的，所以是虚函数指针。关于如何查证和查看虚函数表：找到虚函数指针，得到函数地址并运行，在这里`addr()`的结果为 `Base1` ,即Base中的虚函数。

### 静态联编与动态联编

或者说是前绑定与后绑定，同时，将派生类引用或指针转化为基类引用或指针称为**向上强制转换**，与之相反的是**向下强制转换**。在形参为基类引用或指针时，实际上是隐性向上强制转换使得派生类引用或指针可以传入该参数，编译器对非虚方法使用静态联编，对虚方法采用动态联编。

### protected

protected与private类似，在类外只能使用公有方法才能访问，但是在基类继承上，派生类是能够直接访问基类protected中的成员的。

### 抽象类

c++中使用纯虚函数来表示抽象类。

### 继承与动态分配

对于子类不需要new的，则不需要显式定义析构函数，拷贝构造以及赋值运算符的重载，反之则需要。

对于友元，如果该友元不在基类中，则需要在派生类友元中调用基类友元（因为该友元不在基类中，不具有相应访问权限）。

### 类型转换

使用带有一个相应参数的构造函数就可以实现类型转换，如果在该构造函数添加上`explicit`关键字，则禁止隐性类型切换。

### 组合与私有继承

组合与私有继承都是代码重用的好方法。

组合通常被描述为 获得了成员对象的实现，但是没有继承接口。

私有继承会将基类中的公有和保护方法变为私有方法，所以不会对外暴露接口。保护继承则会将其变为保护方法，这样可以继续继承下去。

在私有继承中，如果想要对外暴露基类的接口，则可以通过使用`using`。

比如说书中的`using std::valarray<int>::min`将min方法从valarray\<int\>中拿了出来。

### 多重继承

c++允许多重继承，而java并不允许，对于继承，派生类会有基类的副本，但是如果多个基类继承自同一个基类，则可以使用**虚基类**来表示这一个基类，这样在这个派生类中，只会有一个副本，而非多个副本，只需在这多个基类继承一个基类时增加`virtual`关键字。

对于多继承来说，如果多个基类有同样的方法，此时在派生类中使用该方法是有二义性的，这里可以通过作用域解析符指定版本，更好的办法是在派生类中增加该方法。

### 类模板

template 中有 类型参数 与 非类型参数 两种，大致为：

```c++
template<typename T, int n>
//  其中T为类型参数，n为非类型参数，或者是表达式参数
```

同时，模板也有默认模板参数如：

```c++
template<typename T,typename T2 = double>
```

遵循和默认参数一样的原则。

模板可以部分具体化，如果有多个模板可供选择，默认选择具体化程度最高的。

**成员模板**，模板参数，可以用来完全实现STL。

### 模板类与友元

- 非模板友元
- 约束友元函数
- 非约束友元函数

对于非模板友元函数，适用于所有实例化了的对象。

### 模板别名

typedef 通常可以使用，也可以用`using typeshort = type`来进行简化。

### 友元类 与 友元成员函数

与友元函数相同，具有类内部成员的权限，友元类只需要在需要处理的类中增加`friend`声明，有时并不需要整个类作为友元，而是其中的某些成员函数，这时需要将成员函数`friend`申明在处理的类中，同时使用前向声明，并且将友元类定义放在该类前。

### 嵌套类

外部对嵌套类的权限与其他成员的原则相同。

### 智能指针

是一种对象，``auto_ptr``（C++98使用，C++11抛弃）,``unique_ptr``,以及``shared_ptr``。，（weak_ptr不谈）。

其中unique_ptr有所有权的概念，同时，shared_ptr拥有计数功能，当计数为0才delete，全都解决了auto_ptr的麻烦。

### 默认方法与禁用方法

如果提供了移动构造函数，那么类将不会提供默认的构造，复制构造以及赋值构造函数，需要显式地使用`= default`来进行声明。类似的，使用 `= delete`可以禁用某一方法。

### 委托构造

一个类可能有多个构造函数，代码可能会导致重复，可以调用其他构造函数。

### override 与 final

如果派生类的继承来的虚方法在基类中并没有对应，那么基类中的虚方法在派生类中将被隐藏（并不会报错），通过override来表示对一个虚方法进行重写，如果不对编译会报错。通过final关键字禁止重写该虚方法。

### Lambda 函数



### 标准模板库STL

学习网站：

[C++ Iterators Introduction | hacking C++ (hackingcpp.com)](https://hackingcpp.com/cpp/std/iterators_intro.html)

#### Iterator

- 默认迭代器：从前往后遍历容器

在C++11中，增加将`begin`与`end`作为了可直接使用的函数。所以对于一个容器如`vector`，有3中迭代方式：

```c++
    std::vector<int> v1 {1,2,3,4,56};
    for (auto i = std::begin(v1); i != std::end(v1);++i) {
        std::cout << *i << std::endl;
    }
    printf("----------\n");
    for (int i = 0; i < v1.size(); ++i) {
        std::cout << v1[i] << std::endl;
    }
    printf("----------\n");
    for (auto x = v1.begin(); x != v1.end(); ++x) {
        std::cout << *x << std::endl;
    }
```

- 反向迭代器：可以从后往前遍历容器

与默认迭代器类似，可以直接将容器作为参数，使用函数为`rbegin`和`rend`。

- 常量迭代器：不改变变量值，并且从前往后遍历。函数为`cbegin`和`cend`。

  

#### 序列容器

`array`<T,size>,`vector<T>`,`deque<T>`,`list<T>`,`forward_list<T>`分别为固定长的数组，向量，双向队列，列表（双向），前向链表（单向）。

`capacity`与`size`是不同的，分别为内存占据的元素数量和当前元素的数量，`reserve`可以重新修订当前最多元素大小，`resize`可以调整当前元素数量并填充。可以在容器初始化时使用迭代器，或者使用`assign`进行赋值。`insert`可以在某个位置插入若干元素。`clear`清楚所有元素，`erase`清除某些元素。



---------------------------------2023-06-21------------------------------