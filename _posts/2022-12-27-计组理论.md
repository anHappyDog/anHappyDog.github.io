---
title: 计组理论
author: lonelywatch
date: 2022-12-27 00:07 +0800
categories: [BUAA，计组]
tags: [计组]
---

## 计组理论

​		xlm老师和gxp老师的ppt结合起来看最好了（为什么我当时要逃课，，）。

### 布尔代数

### CPU

### Cache

#### 原理

​		CPU与主存间的性能差距越来越大，根据局部性原理（时间局部性和空间局部性），有了Cache（高速缓存存储器）来提高性能，多半用SRAM。

​		Cache位于CPU与主存之间，存放最活跃的程序块和数据，大多数情况下CPU直接从Cache中获得数据而非主存。

​		Cache与主存之间以**数据块（Block）**为单位进行数据交换。

​		每个数据块包含若干个字节，Cache块的大小和主存块的大小相等。

​		Cache需要能够快速访问，与主存交换数据，判断CPU访问的数据是否在Cache中，以及不在Cache中时替换Cache块的能力。

#### 基本结构

| v(有效位) | tag（地址标记位） | Block（数据块） |
| --------- | ----------------- | --------------- |

- 有效位：判断数据块是否有效
- 地址标记位：根据地址转换机制的地址标记位
- 数据块:大小和主存块相同，存放数据

其他概念：

- 行(line): 一个有效位，地址标记位，数据块
- 组(set): 若干个数据块组成
- 路(way):Cache相关联的等级，路数即组中块数
- 命中率：目标数据在Cache中的比例
- 缺失率：目标数据不在Cache中的比例

#### 映射机制

主存到Cache的映射，即主存块该存储在Cache中的哪里（当需要时）。

映射方式：

- 全相联映射：每个主存块映射到Cache的任意块
- 直接映射:每个主存块映射到Cache的固定块
- 组相联映射:每个主存块映射到Cache的固定组中的任意块

##### 全相联映射

地址：

主存的地址格式:

| Block Number(tag) | Offset |
| ----------------- | ------ |

Cache中的Tag为该Cache块对应的主存块的块地址

**梨子**：

​	主存容量16M bytes, Cache容量64K bytes，块大小16字节

1. 主存和Cache各分多少块

2. 主存地址的位数是多少，格式是什么

3. Tag需要多少位

   

解：主存块数为 16M / 16 = $2^{20}$ 

​		故主存地址共为24位，20位Tag，4位块内偏移

​		Cache块数为64K / 16 = $2^{12}$

​		Tag需要20位

全相联特点：

- 灵活

- 需要全部比较，电路复杂，仅在Cache容量很小时采用

  

##### 直接映射

​		主存块对应Cache中的固定块。

​		**将主存按Cache的大小分区**，一区的各块与Cache的对应各块映射。

​		主存的地址格式：

| 区地址(Tag) | 区内块地址(index) | 块内偏移（Offset） |
| ----------- | ----------------- | ------------------ |

Cache中的Tag对应主存中的区地址。

**梨子**：

主存容量16 M bytes，Cache容量64K字节，BLOCK块16 Bytes

- Cache中有多少块
- 主存地址有多少位，格式为什么
- Tag为多少位

解：

​		Cache中有64K / 16 = $2^{12}$ 块

​		主存中共有 16M / 16 = $ 2^{20}$块，可分为 $2^{8}$区，故Tag位有位，区内地址Index有12位，块内偏移有4位。

特点:

- 实现简单
- 映射不灵活

##### 组相连映射

​		将Cache分为K组，每组分为L块，主存块J分到I组中的任意块为

​		I = J mod K

​		实际上主存和Cache都分K组，但是主存和Cache组中块数不相同。

主存的地址格式:

| 组内块地址(Tag) | 组地址(Set) | Offset |
| --------------- | ----------- | ------ |

Tag中为主存中与该Cache块对应的数据块的组内块地址。

**梨子**：

​	主存容量1M字节，4路组相联，Cache 16K字节，Block大小256字节

问：

- Cache分多少组，每组多少块

- 主存多少组，每组多少块
- Cache的tag需要多少位

解：

Cache共有 16K / 256 = $ 2^{6}$ 块，每组4块，共有$2^{4}$组

主存共有1M / 256 = $2^{12}$块，分$2^{4}$组，每组 $2^{8}$块

tag需要8位。

---

---

#### 替换策略

​		缺失损失:CPU访问Cache缺失时，CPU必须等待数据装入Cache才能访问，这段时间称为缺失损失。

​		取出块的时间:第一个字的延迟时间 + 块的剩余部分的传送时间。

缺失处理：

- **块装入后访问**:缺失数据块全部装入后，再从Cache中访问请求字
- **尽早重启**:缺失数据块中各字按顺序装入Cache，一旦请求的字装入，则立即访问该字，然后再继续传送剩余数据
- **请求字优先**:所请求的字先装入Cache，CPU立即访问该字，再继续传送剩余数据到Cache

替换策略:

- 最近最少使用法(LRU):最近没有被使用的块被替换

- 先进先出法(FIFO):最先装入数据的块被替换

- 最少使用频率法(LFU):使用次数最少的被替换

- 随机法(RAND):随机选择进行替换

  

![习题1](/assets/img/cothero/52Cache.png)

解:

1:Cache共有 16K / 16 = $2^{10}$块，每组4块，共有$2^{8}$组

2:主存共有$2^{8}$组，共有 16M / 16 = $2^{20}$块，每组$2^{12}$块，故Tag为12位，Index为8位，Offset为4位，共24位

3: 采用LRU，读入2F8086H,063081H会失效，读取结束后，就这样。

#### 性能分析

​		Cache实际的总容量和不特殊声明时的总容量分别为:包含tag和valid bit的 和 不包含的。

---

---

​		存储访问时间: 若 $T_{m}$为主存储器的访问周期，$T_{c}$为Cache的访问周期，$H$为Cache的命中率，则等效访问周期$T = T_{c} * H + T_{m} * (1 - H)$ .

​		加速比:$S_{p} = T_{m} / T $。

---

​		Cache与主存的数据一致性

- 写通过:同时写Cache和主存
- 写回:写操作只更新Cache的数据，知道Block被替换时才协会主存，用(dirty bit)来表示Block换回主存前被修改过。

---

​		Cache块的命中率，一般来说，增加块大小将降低缺失率，但达到某个阶段就会继续增加。

​		我们采用两级Cache（L1为内部Cache，L2为外部Cache）

#### 习题

​		前面有。

### 存储器

​		辅存:容量大，价格低，非易失性，速度低

​		磁盘的性能指标:

- 记录密度：

  - 道密度： 磁盘沿半径方向单位长度的磁道
  - 位密度：单位长度磁道记录二进制的位数

- 存储容量：

  - 盘面数 * 盘面的磁道数 * 磁道中的扇区数 * 扇区容量
  
- 访问时间：$T_{A} = T_{S} + T_{W} $

  - 寻道时间$T_{s}$:磁头从当前位置定位到目标磁道所需时间
  - 寻区时间$T_{w}$:定位磁道后，目标扇区旋转到磁头所需要的时间

- 数据传输率: 单位时间内传输的数据位数(b /s)

### 虚拟存储

#### 概述

​		为了减少小的主存容量对编程的限制，运行多道程序，内存管理采用交换机制，将进程保存在辅存中，进程执行时，只将活跃部分调入内存，这种把主存当作辅存的高速缓存的技术，称为虚拟存储（器）。

---

虚存空间和物理空间:

​		**用户编程空间**：用户编制程序时使用的地址称为**虚地址**，或逻辑地址，对应的存储空间为**虚存空间**或逻辑地址空间，程序按照虚地址编程并存放在辅存中。

​		**物理内存空间**：计算机物理内存的访问地址称为**实地址**，或物理地址，对应的存储空间为**物理空间**或主存空间

---

**虚拟存储的调度方式**:

​		**页式调度**：将虚存空间和物理地址空间分成固定大小的页，主存按页顺序编号，每个独立编制的程序空间也按自己的页顺序编号，虚拟空间和物理空间按页进行交换。

​		**段式调度**：将物理空间分成页；按程序的逻辑结构将程序空间划分为若干段，段长度任意，虚存空间和物理空间按段进行交换。

​		**段页式调度**：把物理空间分成页，程序按模块先分段，每个段再分成与物理空间页相同大小的页，虚存空间和物理空间按页进行交换。

#### 页式虚拟存储器

---

虚存页称为**虚页**，主存页称为**实页**，辅存中的程序按页调入内存。

虚地址格式: 虚页号+ 页内地址

实地址格式:实页号+ 页内地址

**页表**:记录虚页和实页的映射关系，实现虚实地址的转换，建立在内存中。

**页表项**：包括虚页对应的**实页号**和**有效位**

**页表寄存器**：保存页表在内存中的首地址

---

**梨子**：

虚拟地址32位，物理内存128MB，页大小4KB

1：程序虚拟空间最多可有多少页

2：页表项共有多少位

3：每个页表占多少内存空间



解：

实页共有 128M / 4K = $ 2^{15}$ ,共有15位，页内偏移共有 $\log_{2}2^{12} = 12$位

故实地址共有27位。

虚地址有32位，其中页内偏移有12位，故最多有20位虚页地址，虚拟空间共有$2^{20}$页。

页表项共有15 + 1 = 16位

每个页表占据 $2^{20} * 16$ = 16Mb = 2 MB

#### 快表TLB

​		每次访问虚拟存储器都要带来两次存储器访问，我们使用Cache存储部分活跃的页表项，称为TLB（快表）。

​		TLB内容：虚页号（标记），对应实页号，有效位，修改位

​		一般采用全相联

​		内容：

| 有效位 | 修改位 | Tag（虚页号） | 数据（实页号） |
| ------ | ------ | ------------- | -------------- |



---

****

**梨子**；





































