---
title: <<TCP&IP网络编程>>笔记
author: lonelywatch
date: 2023-6-22 15:14 +0800
categories: [计网]
tags: [计网,linux,windows,tcp]
---

# <<TCP&IP网络编程>>

这是一本完全面向初学者的网络编程书,《计算机网络》中的概念太多，我学到一半决定还是先从实用的角度开始，这本书其实我大一尝试看过一点，但也是浅尝辄止，现在拾起来重新学习。

## 第一章

作者直接给出了在windows和linux下的“hello,world”，根据几段程序讲解了服务端与客户端的流程。

在linux下：

```c
//hello_client.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(const char* message) {
	fputs(message,stderr);
	fputc('\n',stderr);
	exit(1);
}

int main(int argc, char** argv) {
	int sock;
	struct sockaddr_in serv_addr;
	char message[30];
	int str_len;
	if (argc != 3) {
		
		printf("Usage : %s <IP> <port>\n",argv[0]);
		exit(1);
	}
	sock = socket(PF_INET,SOCK_STREAM,0);
	if (sock == -1) {
		error_handling("socket() error");
	}
	memset(&serv_addr,0,sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = inet_addr(argv[1]);
	serv_addr.sin_port = htons(atoi(argv[2]));

	if (connect(sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr)) == -1) {
		error_handling("connect() error");
	}
	str_len = read(sock,message,sizeof(message) - 1);
	if (str_len == -1) {
		error_handling("read() error");
	}
	printf("Message from server : %s \n",message);
	close(sock);
	return 0;
}

// hello_server.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(const char* msg);

int main(int argc, char**argv) {
	int serv_sock;
	int clnt_sock;

	struct sockaddr_in serv_addr;
	struct sockaddr_in clnt_addr;
	socklen_t clnt_addr_size;
	char message[]= "Hello world";
	if (argc != 2) {
		printf("Usage : %s <port>\n",argv[0]);
		exit(1);
	}
	serv_sock = socket(PF_INET,SOCK_STREAM,0);
	if (serv_sock == -1) {
		error_handling("socket() error");
	}
	memset(&serv_addr,0,sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_addr.sin_port = htons(atoi(argv[1]));

	if (bind(serv_sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr)) == -1) {
		error_handling("bind() error");
	}
	if (listen(serv_sock,5) == -1) {
		error_handling("listen() error");
	}
	clnt_addr_size = sizeof(clnt_addr);
	clnt_sock = accept(serv_sock,(struct sockaddr*)&clnt_addr,&clnt_addr_size);
	if (clnt_sock == -1) {
		error_handling("accept() error");
	}
	write(clnt_sock,message,sizeof(message));
	close(clnt_sock);
	close(serv_sock);
	return 0;
}

void error_handling(const char* message) {
	fputs(message,stderr);
	fputc('\n',stderr);
	exit(1);
}

```

​	书中说，网络编程就是套接字(socket)编程。

对于服务端，需要这么几步：

- 创建套接字： `socket(int domain,int type,int protocol)`,其中`domain`为指定的 **协议簇**，大致有 `AF_INET`(IPV4),`AF_INET6`(IPV6),`AF_LOCAL`(本地),`AF_PACKET`(原始数据包）。`type`为套接字的通讯方式,取值有`SOCK_STREAM`(流，可靠)，`SOCK_DGRAM`(数据包，不可靠),`protocol`指定具体的协议，通常取0，返回值为-1表示失败。

- 调用`bind`为套接字分配地址:`int bind(int sockfd,struct sockaddr* myaddr, socklen_t addren)`。在linux中，socket被认为是文件的一种，可以通过文件I/O使用（windows不同）`sockfd`为socket描述符，`myaddr`为指向`struct sockaddr`的指针，后面为该结构体的长度，返回-1表示失败。

  其中`struct sockaddr_in`与`struct sockaddr`被定义如下：

  ```c
  struct sockaddr_in {
      sa_family_t sin_family;     // 地址族，在 bind/connect 时通常设置为 AF_INET
      in_port_t sin_port;         // 端口号，使用网络字节序表示
      struct in_addr sin_addr;    // IPv4 地址， INADDR_ANY  表示适用任何地址
      unsigned char sin_zero[8];  // 填充，用0填充以保持与 struct sockaddr 大小相同
  };
  
  struct in_addr {
      in_addr_t s_addr;  // IPv4 地址，使用网络字节序表示
  };
  
  //网络中的通信基本为进程或者线程的通信（我记不清是那个了，，）每个通信者占据一台计算机的一个端口，以此来区分一个ip地址的不同通信者，同时TCP与UDP分别使用端口，如果一个端口被TCP占用，它还可以使用UDP。
  //使用套接字需要为他注册这么一个“门牌”方便寻址。

​		关于宿主机的大小端与网络节序的问题：

- 使用`listen`监听请求：`int listen(int sockfd, int backlog)`

  分别使用sockfd以及

- 使用`accept`接受请求:  `int accept(int sockfd, structaddr* addr, socklen_t* addrlen)`：这里与socket类似，但是通过传入表示大小的指针来返回结果。

对于客户端，则只需要：

- 创建套接字(同服务端)

- 使用`conncect`发送请求`int connect(int sockfd,struct sockaddr* serv_addr, socklen_t addrlen)`，与socket类似。

在windows下需要额外的操作，同时socket是与文件分开的，只需要在编译的时候引入winsock32就可以了。

在windows中，需要使用`WSAStartup`开始使用库，`WSAcleanup`结束对库的使用，`send`与`recv`分别发送和接受信息，`SOCKET` 为socket等函数的返回句柄类型。

### 习题

1. 套接字是数据发送与接受的载体，使得程序员能够从协议中解放出来，因其像插头一样将实体链接至互联网而得名套接字。
2. listen用于监听请求，而accept用于接受请求，建立连接。
3. linux将socket看作为文件的一种，windows并没有。
4. 需要根据ip地址和端口号来寻址，调用bind完成此过程。
5. 文件描述符（Linux）：文件描述符是一个非负整数，在Linux系统中用于标识打开文件、设备或套接字等资源。句柄是Windows系统中表示打开对象（例如文件、设备或套接字）的整数值。
6. ANSI标准定义的IO函数是与操作系统无关的，而底层文件IO与操作系统有关。
7. - - 

## 第二章

协议族在第一章已经说明，关于套接字类型有面向连接`SOCKET_STREAM`与面向消息`SOCKET_DGRAM`两种。

`SOCKET_STREAM`保证数据有序且可靠，并且套接字必须一一对应，没有数据边界。`SOCKET_DGRAM`强调速度，不可靠，可能会丢失，并且有数据边界。	

对于`PF_INET`与`SOCKET_STREAM`的组合，只有`IPPROTO_TCP`一种，即TCP连接。而`SOCKET_DGRAM`对应的组合则是`IPPROTO_UDP`。

是否存在数据边界，书中说只需要看读写次数是否对应。

### 习题

1. 协议指的是一组规则和约定，用于不同系统、设备或实体之间进行通信和交互。定义协议能够使得传输过程变得规范化，使得不认识的双方能够根据协议收发解析数据。

2. 可靠，有序，没有数据边界。

3. a,c,e。

4. UDP,TCP,TCP。

5. UDP，注意缓冲区大小和数据报的长度。

   

## 第三章

大端：最高有效位在低地址，小端：最高有效位在高地址.

关于网络字节序，统一为大端，通过相应函数可以将宿主的大小端转化为网络字节序`htonl`，`htons`,`ntosl`,`ntons`。network 与 host 关于 long与short的切换。

在linux中：

`inet_addr`(arpa/inet.h)将ip地址的字符串转化为32为网络字节序整数值。

`inet_aton`与`inet_addr`具有同样的功能。

`inet_ntoa`与`inet_aton`相反，将32位无符号数转化为字符串IP地址。

`INADDR_ANY`:自动为服务端分配地址。

在windows中：

并不存在`inet_aton`其他相同。

### 习题

1. IPV4 是32位地址，而IPV6是128位地址，IPV6在IPV4将会使用完的情况下产生。

2. 

3. 网络通信的基本节点是进程，一个主机占据一个IP地址，可能会有多个进程同时通信，需要占据不同的端口号进行区分。

4. IP地址分为网络地址与主机地址，分为A,B,C,D,E五个种类。其中A类地址首字节位0 ~ 127， B类为128~ 191 ，C类为192~ 223

   C,A,B

5. 实现外网与本网之间的数据交换。

6. 知名端口就是TCP网络中预先定义且特定保留的端口，FTP代表端口21，HTTP代表端口80，知名端口范围为0~1023

7. `struct sockaddr`中并不好操作，转化为`struct sockaddr_in`方便读取修改。

8. 大端序就是最高有效位在低地址，小端序就是最低有效位在低地址，网络字节序就是大端序。因为主机间的大小端序不同，统一便于管理。

9. 首先大端序不需要将该4字节转化，然后传入小端计算机，转化为小端序。

10. 回送地址就是127.0.0.1,用于与本机通信。

    

## 第四章

先来说说协议栈（chatgpt）：协议栈（Protocol Stack）是计算机网络中的一种概念，它是指在网络通信中用于实现不同层次协议的一组协议的集合。协议栈中的每个协议负责处理特定层次上的通信任务，并按照规定的方式与上下层协议进行交互。TCP/IP协议栈包含多个层次，从底层到高层依次为物理层、数据链路层、网络层、传输层和应用层。

### 习题

1. 应用层，（TCP/UDP）层，IP层，链路层。 分别经过TCP 与 UDP层。

2. 链路层负责将数据转化为字节流进行传输，IP层负责寻址与路由。IP层建立在链路层之上，使用链路层进行传输。

3. 进行标准化设计有利于推广与开发。

4. listen

5. listen，使得套接字可以接受请求，并且设置请求队列，只有listen之后才能使用accept

6. 客户端通过connect在内核使用主机的ip地址，并随机分配端口。

   

## 第五章

